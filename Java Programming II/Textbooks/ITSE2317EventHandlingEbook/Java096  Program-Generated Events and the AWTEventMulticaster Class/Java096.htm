<!--
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
-->
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office">
<head>
<meta content="en-us" http-equiv="Content-Language" />
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />

<title>Java096</title>

<style type="text/css">
a:link {color:#0000ff;}
a:visited {color:#cc00cc;}
a:active {color:#ff0000;}
p{color:black;}
h1{color:green}
h2{color: purple}
h3{color: gray}
b{color: #000000}
strong{color: #000000}
blockquote{color: purple}
ul{color: maroon}
ol{color: maroon}
table{border: 1px solid black}
th{border: 1px solid black}
a:hover {
	color: #cc0000;
	font-weight: bold;
	text-decoration: none;
}
.auto-style1 {
	text-align: center;
}
div.a {
  border: 2px solid black;
}

.auto-style2 {
	text-align: left;
}

</style>

</head>

<body style="font-family: Arial,Helvetica,sans-serif;font-size: 12pt; background-color: #FEFFF0;"
>





<h1 class="auto-style1">Java096 Program-Generated Events and the AWTEventMulticaster Class</h1>

<h1 class="style1">Table of contents</h1>
<ul>
	<li>
	
    <a href="#Figures_and_listings">Figures and listings</a>
	<ul>
		<li><a href="#Figures">Figures</a></li>
		<li><a href="#Listings">Listings</a></li>
	</ul>
    
	</li>
	<li>
	
    
    <a href="#Introduction">Introduction</a>
    </li>
	<li>
	
    
    <a href="#Main_Theme">Main theme
	</a>
</li>
	<li>
	
    
    <a href="#Essential_Ingredients_of_Program-Generated_Events">Essential ingredients of program-generated events
    </a>
</li>
	<li>
	
    
    <a href="#Bare-Bones_Sample_Program">Bare-bones sample program        </a>
	<ul>
		<li>
		<a href="#Interesting_Code_Fragments_from_Bare-Bones_Sample_Program">Interesting code fragments from bare-bones sample program
        </a></li>
		<li><a href="#Program_Listing_for_Bare-Bones_Sample_Program">Program listing for Event25   	</a></li>
	</ul>
</li>
	<li>
	
    
    <a href="#A_more_substantive_sample_program">A more substantial sample program
	</a>
        <ul>
			<li><a href="#Interesting_code_fragments_for_Event24">Interesting 
			Code Fragments from Event24</a></li>
			<li><a href="#Program_listing">Program Listing
    		for Event24</a></li>
	</ul>
        </li>
	<li><a href="#Miscellaneous">Miscellaneous</a></li>
</ul>
	<h1 class="auto-style2"><a name="Figures_and_listings">Figures and listings</a></h1>
	<p>I recommend that you open another copy of this chapter in a separate 
	browser window and use the following links to easily find and view the 
	Figures and Listings while you are reading about them.</p>
	<h2><a name="Figures">Figures</a></h2>
<ul>
	<li>
	<a href="#Figure_1">Figure 1. Output from program named Event25. </a></li>
	<li>
	<a href="#Figure_2">Figure 2. Constructor parameters for ActionEvent.</a></li>
	<li>
	<a href="#Figure_3">Figure 3. Output from program named Event24.</a></li>
</ul>
<h2><a name="Listings">Listings</a></h2>
<ul>
	<li>
	<a href="#Listing_1">Listing 1. Interesting code from the constructor.</a></li>
	<li>
	<a href="#Listing_2">Listing 2. Refer to a list of ActionListener objects.</a></li>
	<li>
	<a href="#Listing_3">Listing 3. Construct a list of ActionListener objects.</a></li>
	<li>
	<a href="#Listing_4">Listing 4. Call the actionPerformed method,</a></li>
	<li>
	<a href="#Listing_5">Listing 5. Program listing for the program named Event25.</a></li>
	<li>
	<a href="#Listing_6">Listing 6. Instantiate NonVisual objects.</a></li>
	<li>
	<a href="#Listing_7">Listing 7. Register ActionListener objects.</a></li>
	<li>
	<a href="#Listing_8">Listing 8. Generate Action events.</a></li>
	<li>
	<a href="#Listing_9">Listing 9, Beginning of the NonVisual class.</a></li>
	<li>
	<a href="#Listing_10">Listing 10. Construct the list of registered objects.</a></li>
	<li>
	<a href="#Listing_11">Listing 11. Part of output from program Event24.</a></li>
	<li>
	<a href="#Listing_12">Listing 12. Cause an ActionEvent to happen.</a></li>
	<li>
	<a href="#Listing_13">Listing 13. Program listing for the program named Event24.</a></li>
</ul>
	
	<h1 class="auto-style2"><a name="Introduction">Introduction</a></h1>
	<p>In previous chapters on event handling, you have learned how to use the
	Source/Listener concept embodied in the Delegation 
	Event Model to handle different types of events generated by visual 
	components on the Graphical User Interface. </p>
<p>In this chapter, we take the subject of event handling one step further by 
showing you how to create and dispatch events under program control. This 
produces the same response as if the events were caused by actions of the user on 
visual components. In other words, you will learn how to create and dispatch 
events under program control that simulate the behavior of a user. 
For example, you might dispatch an event of a given type if a particular 
character were read from a file. </p>
	<h1 class="auto-style2"><a name="Main_Theme">Main theme</a></h1>
	<p>The main theme of this chapter is the use of the <b>AWTEventMulticaster
	</b>class of the Delegation Event Model. This class is used to 
	maintain a list of <b>Listener </b>objects that are registered to be 
	notified whenever an event of a particular type occurs on a particular 
	object and to cause those <b>Listener</b> objects to be notified. In 
	previous chapters, the use of the <b>AWTEventMulticaster</b> class has 
	occurred "under the covers." In this chapter, we will provide some exposure 
	as to how that class does what it does. </p>
<p>As is frequently the case, we will use sample programs to illustrate the 
concepts. In this chapter, we will take it in two steps. </p>
<ul>
	<li>First we will take a look at a bare-bones sample program that 
	illustrates the essential ingredients of program-generated events.</li>
	<li>Then we will take a look at a more substantial program that illustrates 
	the AWTEventMulticaster<b> </b>class of the Delegation Event Model.</li>
</ul>
	<h1 class="auto-style2">
	<a name="Essential_Ingredients_of_Program-Generated_Events">Essential ingredients of 
	program-generated events</a></h1>
	<p>In order to use program-generated events with the techniques described in 
	this chapter, you will need to define a class that is capable of generating 
	the type of events of interest. In this chapter we concentrate on <b>Action
	</b>events. However, there is no reason that you could not use similar 
	techniques to generate low-level events such as mouse events and key events.
</p>
<p>The class must be a subclass of the <b>Component </b>class and must include 
the following three members (as a minimum): </p>
<ul>
	<li>An instance variable that is a reference to a list of registered <b>
	Listener </b>objects. In this program, the <b>Listener </b>objects are of 
	type <b>ActionListener</b>. The instance variable is of type <b>
	ActionListener </b>and could contain a reference to a single object of that 
	type or a reference to a list of objects of that type.</li>
	<li>A method for creating the list mentioned above. In the bare-bones 
	program the method is named <b>makeActionListenerList</b> just to 
	illustrate that the name is not technically important. However, for 
	consistency with documentation on the Delegation Event Model (and other good 
	reasons as well), it should be named <b>addActionListener</b>. The list 
	should be constructed within the body of the method using a call to the <b>
	AWTEventMulticaster.add</b> method which returns a reference to the list. 
	We will discuss the reasons for doing it this way later.</li>
	<li>A method that calls the appropriate action method of the <b>Listener 	</b>class on the list of registered <b>Listener </b>objects. In the sample 
	programs in this chapter, the <b>Listener </b>objects are of type <b>
	ActionListener </b>so the appropriate action method is <b>actionPerformed</b>. 
	For other types of <b>Listener </b>objects, the appropriate action method 
	would be a different method. In these programs, the method that calls the 
	action method of the <b>Listener </b>object is named <b>generateActionEvent</b>. 
	In the bare-bones program, there is only one <b>
	Listener </b>object in the list. In the second program, there are multiple
	<b>Listener</b> objects in the list.</li>
</ul>

<h1><a name="Bare-Bones_Sample_Program">Bare-bones sample program</a></h1>



<p>A non-visual object class (named <strong>NonVisual</strong>) is defined. Objects of this class 
are capable of generating <strong>Action</strong> events. </p>
<p>A single object of the <strong>NonVisual</strong> class is instantiated. A single 
<strong>ActionListener</strong> class is also defined. An object of this class is instantiated 
and registered to listen for <strong>Action</strong> events on the <strong>NonVisual</strong> object. </p>
<p>Then the<strong> generateActionEvent</strong> method is called on the <strong>NonVisual</strong> object 
causing an <strong>Action</strong> event to be trapped and processed by the 
<strong>ActionListener</strong> 
object. The processing is simply to display information identifying the 
<strong>NonVisual</strong> object that generated the event. </p>
<p>The output from the program is shown in <a href="#Figure_2">Figure 1</a> below.</p>

<div class="a">
	<a name="Figure_1">Figure 1</a>. Output from program named Event25.
	<pre>Copyright, R.G.Baldwin
actionPerformed() method called on NonVisualObject</pre>
</div>
<h2><a name="Interesting_Code_Fragments_from_Bare-Bones_Sample_Program">Interesting 
code fragments from bare-bones sample program</a></h2>
<p>The first interesting code fragment is the code in the constructor that </p>
<ul>
	<li>instantiates an object of the new <b>NonVisual</b> type,</li>
	<li>calls the <b>makeActionListenerList</b> method on the <b>NonVisual</b> 
	object to register a <b>Listener </b>object on the <b>NonVisual</b> object, 
	and</li>
	<li>calls the <b>generateActionEvent</b> method on the <b>NonVisual</b> 
	object to cause an <b>Action </b>event to be generated by the <b>NonVisual</b> 
	object.</li>
</ul>
<p>This code is shown in <a href="#Listing_1">Listing 1</a> below.</p>
<div class="a">
	<p><a name="Listing_1">Listing 1</a>. Interesting code from the constructor.</p>

<pre>
 NonVisual nonVisualObject = new NonVisual("NonVisualObject");
 nonVisualObject.makeActionListenerList(new AnActionListenerClass());
 nonVisualObject.generateActionEvent();
</pre>
</div>

<p>The next interesting code fragment is the declaration of the instance 
variable in the <b>NonVisual</b> class definition that will refer to a list of 
registered <b>Listener </b>objects. (See <a href="#Listing_2">Listing 2</a>.) As 
mentioned earlier, this instance variable could just as easily refer to a single 
object of the <b>ActionListener </b>type 
as to refer to a list of such objects. In fact, in this bare-bones program it 
does refer to a single instance of an <b>ActionListener </b>object as we will 
discuss in more detail later. </p>
<div class="a">
	<p><a name="Listing_2">Listing 2</a>. Refer to a list of ActionListener 
	objects.</p>

<pre>
ActionListener actionListener;//list of registered action listener objects
</pre>
</div>

<p>The next interesting code fragment is the statement that is used to construct 
the list of registered <b>Listener </b>objects by adding a new object to the 
list. (See <a href="#Listing_3">Listing 3</a>.)</p>
<p>The first time this statement is executed in a program, it simply returns a 
reference to the object being added to the list. </p>
<p>If it is executed a second time, it returns a reference to a list of objects 
that is being maintained separately (this is explained more fully later). </p>
<p>In the bare-bones program, only one <b>Listener </b>object is added to the 
list. If we were to examine the contents of the reference returned by the <b>
AWTEventMulticaster.add</b> method, we would find that it is simply a reference 
to the object. In a later program, we will see how it refers to a list when more 
than one object is added to the list. </p>
<div class="a">
	<p><a name="Listing_3">Listing 3</a>. Construct a list of ActionListener 
	objects.</p>

<pre>
 actionListener = AWTEventMulticaster.add(actionListener, listener);
</pre>
</div>

<p>The final interesting code fragment in this bare-bones program is the 
statement that calls the <b>actionPerformed </b>method of the <b>
ActionListener </b>object, or more properly calls that method on all the objects 
in the list of registered <b>ActionListener</b> objects. </p>
<p>All we have to do is to call the method once on the instance variable that 
refers to the list and the system takes care of calling the 
method on all the objects in the list. This is the <b>central feature</b> of the
<b>AWTEventMulticaster</b> class. </p>
<p>As you can see, this code instantiates an object of type <b>ActionEvent</b> 
and passes that object's reference as a parameter to the <b>actionPerformed</b> method, 
thus satisfying the signature requirements of the <b>actionPerformed</b> 
method.</p>

<div class="a">
	<p><a name="Listing_4">Listing 4</a>. Call the actionPerformed method,</p>

<pre>
 actionListener.actionPerformed(
     new ActionEvent(this, ActionEvent.ACTION_PERFORMED, ID));
</pre>
</div>

<p>The parameters for the <b>ActionEvent</b> constructor are shown in
<a href="#Figure_2">Figure 2</a> below. </p>
<div class="a">
	<p><a name="Figure_2">Figure 2</a>. Constructor parameters for ActionEvent.</p>

<pre>
public ActionEvent(Object source, int id, String command)

Constructs an ActionEvent object with the specified source object.

Parameters:
source - the object where the event originated
id - the type of event
command - the command string for this action event

</pre>
</div>

<p>So there you have the essential ingredients of program-generated events reduced to code fragments. A complete listing of the program is contained in the next section. </p>
<h2><a name="Program_Listing_for_Bare-Bones_Sample_Program">Program listing for 
Event25</a></h2>
<p>This section contains a complete listing of the bare-bones program named <strong>Event25</strong>. Refer to previous sections for an operational 
description of the program. </p>
<div class="a">
	<p><a name="Listing_5">Listing 5</a>. Program listing for the program named 
	Event25.</p>

<pre>
/*File Event25.java Copyright, R.G.Baldwin
This program is designed to be compiled and run under JDK 1.1

This is a bare-bones program that illustrates Program Generated
Events under JDK 1.1.

The output from the program is:

Copyright, R.G.Baldwin
actionPerformed() method called on NonVisualObject

The program was tested using JDK 1.1 running under Win95.
*/
//=======================================================================
import java.awt.*;
import java.awt.event.*;
//=======================================================================

public class Event25 {
 public static void main(String[] args){
 new Event25();//instantiate an object of this type
 }//end main
//-------------------------------------------------------------------------
 public Event25(){//constructor
 System.out.println("Copyright, R.G.Baldwin");
 NonVisual nonVisualObject = new NonVisual("NonVisualObject");
 nonVisualObject.makeActionListenerList(new AnActionListenerClass());
 nonVisualObject.generateActionEvent();
 }//end constructor
}//end class Event25
//========================================================================

//Class to respond to action events
class AnActionListenerClass implements ActionListener{
 public void actionPerformed(ActionEvent e){
 System.out.println(
 "actionPerformed() method called on " + e.getActionCommand());
 }//end actionPerformed
}//end class AnActionListenerClass
//========================================================================

//Class to create object capable of generating Action events.
//-------------------------------------------------------------------------
class NonVisual extends Component {
 String ID; // The ID of the object
 ActionListener actionListener;//list of registered action listener objects
 //-----------------------------------------------------------------------
 public NonVisual(String ID) {//Constructs a NonVisual object
 this.ID = ID;
 }//end constructor
 //-----------------------------------------------------------------------
 public void makeActionListenerList(ActionListener listener) {
 actionListener = AWTEventMulticaster.add(actionListener, listener);
 }//end makeActionListenerList()
 //-----------------------------------------------------------------------
 public void generateActionEvent() {
 actionListener.actionPerformed(
 new ActionEvent(this, ActionEvent.ACTION_PERFORMED, ID));
 }//end generateActionEvent
}//end class NonVisual
</pre>
</div>

<h1><a name="A_more_substantive_sample_program">A more substantial sample program</a></h1>
<p>The next program is more substantial and is designed to illustrate the 
ability of the <b>AWTEventMulticaster </b>class to dispatch events to more than 
one <b>Listener </b>object in a list of registered <b>Listener </b>objects. </p>
<p>A non-visual object class (named <b>NonVisual</b>) is defined. Objects of 
this class are capable of generating <b>Action </b>events. The mechanism for 
causing an object of this type to generate an <b>Action </b>event is to call the
<b>generateActionEvent</b> method on an object of the class. </p>
<p>Two objects of the <b>NonVisual </b>class are instantiated. Also, two 
different <b>ActionListener </b>classes are defined. </p>
<p>An <b>ActionListener </b>object of one of these classes is instantiated and 
registered to listen for <b>Action </b>events on both of the objects of the <b>
NonVisual </b>class. </p>
<p>An object of the other <b>ActionListener </b>class is 
instantiated and registered to listen for <b>Action </b>events on only one of 
the <strong>NonVisual</strong> objects. </p>
<p>Thus, one <b>NonVisual </b>object is registered with only one <b>
ActionListener </b>object. The other <b>NonVisual </b>object is registered with 
two different <b>ActionListener </b>objects. </p>
<p>The registration of two different <b>ActionListener </b>objects on a single
<b>NonVisual </b>object requires the <b>AWTEventMulticaster </b>class to 
dispatch <b>Action </b>events to two different <b>Listener </b>objects and 
illustrates the central feature of the <b>AWTEventMulticaster</b> class. </p>
<p>After the <b>NonVisual </b>objects are instantiated and the <b>ActionListener
</b>objects are registered on the <b>NonVisual </b>objects, the <b>
generateActionEvent</b> method is called on each of the <b>NonVisual </b>
objects. This causes <b>Action </b>events to be generated and to be trapped and 
processed by the respective <b>ActionListener </b>objects. </p>
<p>Numerous statements are included to explain what is happening along the way. 
All of the output from the program goes to the standard output device. </p>
<p>The output from the program for one particular run is shown in 
<a href="#Figure_3">Figure 3</a> 
below, Some hard return characters were manually inserted to force the text to 
fit on the printed page. </p>
<div class="a">
	<p><a name="Figure_3">Figure 3</a> Output from program named Event24.</p>

<pre>
Copyright, R.G.Baldwin
Instantiate two NonVisual objects with the ability to generate Action events.
Name of first NonVisual object: NonVisualObjA
Name of second NonVisual object: NonVisualObjB

Register ActionListener objects on the NonVisual objects

addActionListener() method called
NonVisualObj A:   Listener to add is: FirstActionListener@b81eda8
Call AWTEventMulticaster.add() to get reference to ActionListener
NonVisualObj A:   Ref to ActionListener is: FirstActionListener@b81eda8


addActionListener() method called
NonVisualObj B:   Listener to add is: FirstActionListener@67424e82
Call AWTEventMulticaster.add() to get reference to ActionListener
NonVisualObj B:   Ref to ActionListener is: FirstActionListener@67424e82


addActionListener() method called
NonVisualObj B:   Listener to add is: SecondActionListener@531d72ca
Call AWTEventMulticaster.add() to get reference to ActionListener
NonVisualObj B:   Ref to ActionListener is: java.awt.AWTEventMulticaster@22d8cfe0

Call generateActionEvent() method on the object named NonVisualObjA
which has only one registered ActionListener object.
In generateActionEvent() method, dispatching ACTION_PERFORMED event to
FirstActionListener@b81eda8 for NonVisualObj A
In actionPerformed() method of FirstActionListener object
actionPerformed() method called on NonVisualObj A

Call generateActionEvent() method on the object named NonVisualObjB
which has two registered ActionListener objects.
In generateActionEvent() method, dispatching ACTION_PERFORMED event to
java.awt.AWTEventMulticaster@22d8cfe0 for NonVisualObj B
In actionPerformed() method of FirstActionListener object
actionPerformed() method called on NonVisualObj B
In actionPerformed() method of SecondActionListener object
actionPerformed() method called on NonVisualObj B</pre>
</div>

<h1><a name="Interesting_code_fragments_for_Event24">Interesting code fragments from Event24</a></h1>
<p>Much of the code in this program replicates code that you have seen in 
previous programs. In addition, much of the code consists of<b> 
System.out.println</b> statements that are there to explain what is happening 
when you view the output. For the most part, we will skip code that you have 
seen before and concentrate only on the code that is germane to the objective of 
this program -- illustration of program-generated events with particular 
emphasis on the <b>AWTEventMulticaster </b>class. </p>
<p>The first interesting code fragment instantiates two objects of the <b>
NonVisual </b>class with labels and assigns names to the objects. When you 
assign names in this manner, you should make certain that you assign a unique 
name to each object. </p>
<div class="a">
	<p><a name="Listing_6">Listing 6</a>. Instantiate NonVisual objects.</p>

<pre>
 NonVisual aNonVisual = new NonVisual("NonVisualObj A");
 aNonVisual.setName("NonVisualObjA");

 NonVisual bNonVisual = new NonVisual("NonVisualObj B");
 bNonVisual.setName("NonVisualObjB");
</pre>
</div>

<p>The next interesting code fragment registers <b>ActionListener </b>objects on 
the two <b>NonVisual </b>objects as described earlier. Note that unlike the 
bare-bones program, this program uses the conventional name of <b>
addActionListener</b> for the method that generates the list of registered <b>
ActionListener </b>objects. </p>
<div class="a">
	<p><a name="Listing_7">Listing 7</a>. Register ActionListener objects.</p>

<pre>
 aNonVisual.addActionListener(new FirstActionListener());
 bNonVisual.addActionListener(new FirstActionListener());
 bNonVisual.addActionListener(new SecondActionListener());
</pre>
</div>

<p>The next interesting code fragment causes each of the <b>NonVisual </b>
objects to generate an <b>Action </b>event. Note that some uninteresting code 
was deleted between these two statements shown in <a href="#Listing_8">Listing 8</a> below. </p>
<div class="a">
	<p><a name="Listing_8">Listing 8</a>. Generate Action events.</p>

<pre>
 aNonVisual.generateActionEvent();
 ...
 bNonVisual.generateActionEvent();
</pre>
</div>

<p>This is followed in the program by two relatively-standard <b>ActionListener
</b>class definitions that won't be repeated here. </p>
<p>The next interesting code fragment is the beginning of the <b>NonVisual </b>
class that extends the <b>Component </b>class and the declaration of two 
instance variables of the class. (Note that some comments were removed from the 
code fragment.) </p>
<div class="a">
	<p><a name="Listing_9">Listing 9</a>. Beginning of the NonVisual class.</p>

<pre>
class NonVisual extends Component {
 ...
 String ID; // The ID of the object
 ActionListener actionListener;
</pre>
</div>

<p>The first instance variable in <a href="#Listing_9">Listing 9</a> is a 
reference to the identification of the object that is passed in as a parameter 
when the object is instantiated. In our program, this is a <b>String </b>object provided as a 
parameter to the constructor when the <b>NonVisual </b>object is instantiated.
</p>
<p>The constructor consists of a single assignment statement that assigns its 
incoming parameter to this instance variable, so we won't show it here. </p>
<p>The next instance variable in <a href="#Listing_9">Listing 9</a> with the 
identifier of <b>actionListener</b> is 
vital to this program. </p>
<p>Once <b>ActionListener </b>objects are registered on this <b>NonVisual </b>
object, this instance variable will either </p>
<ul>
	<li>contain a reference to a single <b>ActionListener </b>object (if there 
	is only one <b>ActionListener </b>object), or</li>
	<li>contain a reference to an object of type <b>AWTEventMulticaster </b>(if 
	there is more than one <b>ActionListener </b>object).</li>
</ul>
<p>In the second case, when we later call the <b>actionPerformed</b> method on 
the instance variable named <b>actionListener</b>, we will in fact be calling 
that method on an object of type <b>AWTEventMulticaster </b> That will, in turn, 
call the method on all of the objects of type <b>ActionListener </b>contained in 
the list of <b>ActionListener</b> objects registered on the <b>NonVisual</b> 
object. As mentioned earlier, this is the central feature of the <b>
AWTEventMulticaster </b>class. </p>
<p>The next interesting code fragment is the code that constructs the list of 
objects registered as <b>Listener </b>objects on a specific <b>NonVisual </b>
object. </p>
<p>New objects are added to the list by calling the static <b>add</b> method of 
Class <b>java.awt.AWTEventMulticaster</b> and passing to it the instance 
variable that references the list along with the new <b>Listener </b>object to 
be added to the list. </p>
<p>When the first object is added to the list, a reference to the <b>Listener
</b>object itself is returned. Hence, in the case of a list containing a single
<b>Listener </b>object, the reference to the list is simply a reference to the
<b>Listener </b>object. </p>
<p>When additional <b>Listener </b>objects are added to the list, a reference to 
an object of type <b>java.awt.AWTEventMulticaster</b> is returned by the <b>add</b> 
method of class <b>AWTEventMulticaster</b>. According to the JDK 1.1 
documentation on class <b>AWTEventMulticaster</b>, </p>

<blockquote>"This class will manage the structure of a
chain of event listeners and dispatch events
to those listeners."</blockquote>
<p>When the <b>actionPerformed</b> method is later called on the reference to 
the list, the method will be called either on a single object of type <b>
ActionListener</b> or will be called on an object of type <b>AWTEventMulticaster</b>. 
In the second case, the <b>actionPerformed</b> method of class <b>
AWTEventMulticaster </b>assumes responsibility for calling the <b>
actionPerformed</b> method on all the objects in the list. </p>
<p>With that long introduction, the code fragment shown in Listing 10 is 
relatively simple.</p>
<div class="a">
	<p><a name="Listing_10">Listing 10</a>. Construct the list of registered 
	objects.</p>

<pre>
actionListener = AWTEventMulticaster.add(actionListener, listener);
</pre>
</div>

<p>Of particular interest to us is the output produced by the program when two 
different <b>ActionListener </b>objects are registered on a single <b>NonVisual
</b>object as shown in <a href="#Listing_11">Listing 11</a>. In this case, pay 
particular attention to the identification of the <b>Listener </b>object passed in as a parameter 
to the <b>addActionListener</b> method and the identification of the object 
ultimately referenced by the instance variable that references the list. </p>
<p>When the first <b>Listener </b>object was added to the list, the reference 
was set to the object itself. When the second Listener object was added to the 
list, the reference was set to <b>java.awt.AWTEventMulticaster@22d8cfe0.</b> </p>
<p>A portion of the output from the program illustrating this behavior is shown 
in <a href="#Listing_11">Listing 11</a>. </p>

<div class="a">
	<p><a name="Listing_11">Listing 11</a>. Part of output from program Event24.</p>

<pre>
addActionListener() method called
NonVisualObj B:   Listener to add is: FirstActionListener@67424e82
Call AWTEventMulticaster.add() to get reference to ActionListener
NonVisualObj B:   Ref to ActionListener is: FirstActionListener@67424e82


addActionListener() method called
NonVisualObj B:   Listener to add is: SecondActionListener@531d72ca
Call AWTEventMulticaster.add() to get reference to ActionListener
NonVisualObj B:   Ref to ActionListener is: java.awt.AWTEventMulticaster@22d8cfe0

</pre>
</div>

<p>The next interesting code fragment occurs in a method named <b>
generateActionEvent</b>. The purpose of this method is to instantiate an <b>
ActionEvent</b> object and to call the <b>actionPerformed</b> method on the 
reference to the list of <b>ActionListener </b>objects, passing the <b>
ActionEvent </b>object as a parameter. </p>
<div class="a">
	<p><a name="Listing_12">Listing 12</a>. Cause an ActionEvent to happen.</p>

<pre>
actionListener.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, ID));
</pre>
</div>

<p>As mentioned earlier, a lot of output statements were included in this 
program so that the output would contain an explanation of what is happening as 
the program executes. This section has highlighted only the code necessary to 
implement program-generated events with multicasting. A complete listing of the 
program is contained in the next section. </p>
<h1><a name="Program_listing">Program listing for Event24</a></h1>
<p>This section contains a complete listing of the program. See the previous 
sections for an operational description of the program. </p>
<div class="a">
	<p><a name="Listing_13">Listing 13</a>. Program listing for the program 
	named Event24.</p>

<pre>
/*File Event24.java Copyright, R.G.Baldwin
*/
//=======================================================================
import java.awt.*;
import java.awt.event.*;
//=======================================================================

public class Event24 {
 public static void main(String[] args){
 new Event24();//instantiate an object of this type
 }//end main
//-------------------------------------------------------------------------
 public Event24(){//constructor
 System.out.println("Copyright, R.G.Baldwin");
 System.out.println("Instantiate two NonVisual objects with the "
 + "ability to generate Action events.");
 NonVisual aNonVisual = new NonVisual("NonVisualObj A");
 aNonVisual.setName("NonVisualObjA");
 NonVisual bNonVisual = new NonVisual("NonVisualObj B");
 bNonVisual.setName("NonVisualObjB");

 System.out.println("Name of first NonVisual object: " +
 aNonVisual.getName());
 System.out.println("Name of second NonVisual object: " +
 bNonVisual.getName());

 //Register cross-linked ActionListener
 // objects on the NonVisual objects.
 // One NonVisual object is registered on a
 // single ActionListener object.
 // The other NonVisual object is registered on
 // two different ActionListener
 // objects, one of that is of the same class
 // as the object registered on
 // the first NonVisual object.
 System.out.println(
 " ActionListener objects on the NonVisual objects");
 aNonVisual.addActionListener(new FirstActionListener());
 bNonVisual.addActionListener(new FirstActionListener());
 bNonVisual.addActionListener(new SecondActionListener());

 //Now cause each of the NonVisual objects to generate an Action event.
 System.out.println(
 "Call generateActionEvent() method on the object named "
 + aNonVisual.getName());
 System.out.println(
 "that has only one registered ActionListener object.");
 aNonVisual.generateActionEvent();//do it
 System.out.println();//blank line
 System.out.println(
 "Call generateActionEvent() method on the object named "
 + bNonVisual.getName());
 System.out.println(
 "that has two registered ActionListener objects.");
 bNonVisual.generateActionEvent();//do it

 }//end constructor
}//end class Event24
//========================================================================
//The following two classes are standard ActionListener classes. Objects
// of these classes simply trap Action events and display some information
// about them.

//First class to respond to action events
class FirstActionListener implements ActionListener{
 public void actionPerformed(ActionEvent e){
 System.out.println(
 "In actionPerformed() method of FirstActionListener object");
 System.out.println(
 "actionPerformed() method called on " + e.getActionCommand());
 }//end actionPerformed
}//end class FirstActionListener
//========================================================================
//Second class to respond to action events
class SecondActionListener implements ActionListener{
 public void actionPerformed(ActionEvent e){
 System.out.println(
 "In actionPerformed() method of SecondActionListener object");
 System.out.println(
 "actionPerformed() method called on " + e.getActionCommand());
 }//end actionPerformed
}//end class FirstActionListener


//////////////////////////////////////////////////////////////////////////
// The following class produces a NonVisual object capable of generating
// Action events.
//========================================================================
class NonVisual extends Component {
 //The state of a NonVisual object at any time is defined by the following
 // instance variables.
 String ID; // The ID of the object
 ActionListener actionListener;//Refers to a list of ActionListener
 // objects to be notified when an Action
 // event occurs. (See addActionListener
 // description below).

 //-----------------------------------------------------------------------
 public NonVisual(String ID) {//Constructs a NonVisual object
 this.ID = ID;
 }//end constructor

 //-----------------------------------------------------------------------
 //The behavior of a NonVisual object is defined by the following
 // instance methods.
 //-----------------------------------------------------------------------

 /*
 The following method adds ActionListener objects passed in as parameters
 to the list of ActionListener objects designated to be notified of
 action events from a NonVisual object.

 Notification takes place in a different method by calling the
 actionPerformed() method of each of the ActionListener objects on
 the list.

 New objects are added to the list by calling the static add() method
 of Class java.awt.AWTEventMulticaster and passing to it the instance
 variable that references the list along with the new listener object
 to be added.

 For the first listener object added to the list, a reference to the
 Listener object itself is returned. Hence, in that case the reference
 to the list is simply a reference to the Listener object.

 When additional listener objects are added to the list, a reference
 to an object of type java.awt.AWTEventMulticaster is returned by the
 add() method of Class AWTEventMulticaster.

 According to the JDK 1.1 documentation on Class AWTEventMulticaster,
 "This class will manage the structure of a chain of event
 listeners and dispatch events to those listeners."

 When the actionPerformed() method is later called on the reference to
 the list, either the actionPerformed() method is called on a single
 object, or the AWTEventMulticaster object assumes responsibility for
 calling the actionPerformed() method on all of the Listener objects
 that it is maintaining in its list of Listener objects.
 */
 public void addActionListener(ActionListener listener) {
 System.out.println();//blank line
 System.out.println("addActionListener() method called");
 System.out.println(ID + ": Listener to add is: " + listener);
 System.out.println("Call AWTEventMulticaster.add() to get "
 + "reference to ActionListener");
 actionListener = AWTEventMulticaster.add(actionListener, listener);
 System.out.println(ID + ": Ref to ActionListener is: " +
 actionListener);
 System.out.println();//blank line
 }//end addActionListener()
 //-----------------------------------------------------------------------
 //The purpose of this method is to call the actionPerformed() method
 // on all the Listener objects that are contained in a list of Listener
 // objects that are registered to listen for Action events being
 // generated by this NonVisual object. This is accomplished by calling
 // the actionPerformed() method on the reference to the list. When this
 // is done, an ActionEvent object is instantiated and passed
 //as a parameter.
 public void generateActionEvent() {
 if(actionListener != null) {
 //confirm that an ActionListener is registered
 System.out.println("In generateActionEvent() method, dispatching "
 + "ACTION_PERFORMED event to ");
 System.out.println(actionListener + " for " + ID);
 actionListener.actionPerformed(new ActionEvent(
 this, ActionEvent.ACTION_PERFORMED, ID));
 }//end if on actionListener
 }//end paint
}//end class NonVisual
//===========================================================
</pre>
</div>


	<h1 class="style1"><a name="Miscellaneous">Miscellaneous</a></h1>
	<p>This section contains a variety of miscellaneous information.</p>

<!--Set border to 15 to create a note. Paragraph elements inside the note are allowed but not required.-->
<div class="a">
	<p><strong>Housekeeping material</strong>
				</p>
				<ul>
					<li>Author: Prof. Richard G. Baldwin</li>
					<li>Chapter name: Java096 Program-Generated Events and the AWTEventMulticaster Class</li>
					<li>File: Java096.java</li>
					<li>Published: March 23, 1997</li>
					<li>Revised: May 26, 2021</li>
				</ul>
</div>

<!--Set border to 15 to create a note. Paragraph elements inside the note are allowed but not required.-->
	<p>-end- </p>


</body>
</html>