<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>... in Java by Richard G Baldwin</TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080" >

<P><!--start--></P>
<I><H3 ALIGN="CENTER">Richard G Baldwin (512) 223-4758, </I><A HREF="mailto:baldwin@austin.cc.tx.us"><I>baldwin@austin.cc.tx.us</I></A><I>, </I><A HREF="http://www2.austin.cc.tx.us/baldwin/"><I>http://www2.austin.cc.tx.us/baldwin/</I></A></H3>
<H2 ALIGN="CENTER"><!--title-->Event Handling in JDK 1.1, Handling Events in Extended Components without Listener Objects<!--endtitle--></H2>
<P>Java Programming, Lecture Notes # 102, Revised 04/20/22. </P>

<UL>
<LI><A HREF="#preface">Preface</A> </LI>
<LI><A HREF="#introduction">Introduction</A> </LI>
<LI><A HREF="#essential_ingredients_for_extending_exis">Essential Ingredients for Extending Existing Components</A> </LI>
<LI><A HREF="#sample_program">Sample Program</A> </LI>

<UL>
<LI><A HREF="#interesting_code_fragments">Interesting Code Fragments</A> </LI>
<LI><A HREF="#program_listing">Program Listing</A></LI></UL>

<LI><A HREF="#review">Review</A></LI></UL>

<P><HR></P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="preface"></A>Preface</H2>
</FONT><P>Students in Prof. Baldwin's <B><U>Intermediate Java Programming</B></U> classes at ACC are responsible for knowing and understanding all of the material in this chapter. </P>
<P>JDK 1.1 was formally released on February 18, 1997 and JDK 1.1.1 was formally released on March 27, 1997. This chapter was originally written on March 29, 1997 using the software and documentation in the JDK 1.1 download package because I experienced installation problems with JDK 1.1.1 and I had not succeeded in getting it installed by March 29. </P>
<P>On 2/25/99, the sample program in this chapter was confirmed to work properly under JDK 1.2 and Win95.</P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="introduction"></A>Introduction</H2>
</FONT><P>The purpose of this chapter is to illustrate one way that you can create your own custom components by extending the existing components. When you extend an existing component, you need to handle the events associated with the new component. </P>
<P>This chapter demonstrates an event-handling approach for the events on the new component that does not follow the <I>Source/Listener</I> mode of the <I>Delegation Event Model</I>. Sometimes this approach can be more compact. However, you should take a look at the cautions in the JDK 1.1 documentation regarding this approach. </P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="essential_ingredients_for_extending_exis"></A>Essential Ingredients for Extending Existing Components</H2>
</FONT><P>Using the techniques illustrated in this program, the essential ingredients for creating and handling events on an extended component are: </P>

<UL>
<LI>Define and instantiate the primary container for the <B>GUI</B>. In this chapter, the primary container extends <B>Frame</B>. </LI>
<LI>Define the class for the new component and make it <I>extend </I>an existing component. In this program the class for the new component <I>extends </I><B>TextField</B>. </LI>
<LI>Create a mechanism for handling events on the new component. In this program, the mechanism is an overridden <B>processKeyEvent()</B> method. Note that <B>processKeyEvent()</B> is only one of several available methods that you can override. Other available methods include <B>processMouseEvent()</B>, <B>processActionEvent()</B>, etc. </LI>

<UL>
<LI>If you use methods such as <B>processKeyEvent()</B> for processing events, you must <I>enable </I>events of the proper type using statements such as <B>enableEvents(AWTEvent.KEY_EVENT_MASK)</B>. A good place to put this statement is in the constructor for the object of the new type. </LI>
<LI>Also, if you override one of the event processing methods such as <B>processKeyEvent()</B> you <U>must always</U> invoke the superclass version of the same event using a statement such as <B>super.processKeyEvent(e)</B> passing it the event object as a parameter. </LI>
<LI>If you take this approach, it isn't necessary to instantiate and register listener objects on the new components. Rather, all of the event handling code can be placed inside the <B>processKeyEvent()</B> method.</LI></UL>

<LI>Add the new component to its container.</LI></UL>

<P>. <br/>
 </P>
<TABLE BORDER CELLSPACING=1 WIDTH=624>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P>The following rather long explanation of the rule regarding <B>super.processKeyEvent(e) </B>along with a sample program was extracted from the JavaSoft JDK 1.1.3 documentation at the location shown below. </P>
<P>/java/docs/guide/awt/designspec/events.html </P>
<P>The most important information has been highlighted using boldface. </P>
<P>Note in particular the <I>unconditional </I>call to <B>super.processFocusEvent(e)</B> at the end of the method named <B>processFocusEvent(FocusEvent e)</B>. Not all books show this as an unconditional call. <br/>
 </TD>
</TR>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<PRE>By default, the single processEvent method will invoke the proper
event-class processing method. The event-class processing method by
default will invoke any listeners, which are registered.


<B>It's important to remember that these methods perform a critical
function in the event processing for an AWT component and so if you
override them you should remember to call the superclass' method
somewhere within your own!

</B>Selecting for Event Types

One of the goals of the listener model is to improve performance by NOT
delivering events which components are not interested in. By default, if
a listener type is not registered on a
component, then those events will NOT be delivered and these processing
methods will therefore NOT be called. So if you are using this extension
mechanism for event-handling, you'll need to select for the specific
types of events your component wishes to receive (in case no listener is
registered). This can be done by using the following method on
java.awt.Component:

 protected final void enableEvents(long eventsToEnable)

The parameter to this method is a bitwise mask of the event types you
wish to enable. The event masks are defined in java.awt.AWTEvent. Note
that changing this mask will not affect the delivery of events to
listeners -- it only controls the delivery to the component's processing
methods. The bottom line is that the set of events which are delivered
to processEvent() is defined by the union of event types which have
listeners registered and event types explicitly turned on via
enableEvents().

Example using Extension Mechanism

Following is an example of how this extension mechanism may be used. For
Example, if a subclass of java.awt.Canvas wishes to render some visual
feedback when it receives/loses keyboard focus, it could do the
following.


 public class TextCanvas extends Canvas {
 boolean haveFocus = false;

 public TextCanvas() {
 enableEvents(AWTEvent.FOCUS_EVENT_MASK);
 ...
 }
 protected void processFocusEvent(FocusEvent e) {
 switch(e.getID()) {
 case FocusEvent.FOCUS_GAINED:
 haveFocus = true;
 break;
 case FocusEvent.FOCUS_LOST:
 haveFocus = false;
 }
 repaint();

 <B>// let superclass dispatch to listeners
</B> <B>super.processFocusEvent(e);</B>
 }
 public void paint(Graphics g) {
 if (haveFocus) {
 // render focus feedback...
 }
 }
 ...rest of TextCanvas class...
 }</PRE></TD>
</TR>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff">
<P></TD>
</TR>
</TABLE>

<P>Note that this is not the only way to handle events on extended components. Event handling in JDK 1.1 is extremely flexible. This is simply the way chosen for this particular chapter. </P>
<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="sample_program"></A>Sample Program</H2>
</FONT><P>This program is designed to be compiled and run under JDK 1.1. It illustrates the ability to handle events in extended components without the requirement to use <B>Listener </B>objects. </P>
<P>The program extends <B>TextField </B>to create a new type of <I>text field </I>component named <B>NumericTextField</B>. Objects of the <B>NumericTextField</B> type will only accept numeric input. If the user attempts to enter any character other than <I>0 through 9</I>, an audible alarm sounds (assuming the system setup supports audible alarms) and the character is not accepted by the runtime system. </P>
<P>The controlling class for the program extends <B>Frame</B>. Thus, all the <B>GUI </B>action takes place inside a <B>Frame </B>object. </P>
<P>A total of three component objects are instantiated and added to the <B>Frame </B>object. One of the objects is an object of the new <B>NumericTextField </B>class described above. </P>
<P>A second object is a standard <B>Button </B>object. The third object is a <B>Label </B>object. </P>
<P>Whenever the user clicks on the <B>Button</B>, the <B>String </B>data inside the <B>NumericTextField </B>object is copied into the <B>Label </B>object. </P>
<P>If the user clicks on the <I>close </I>button on the <B>Frame</B>, the program terminates. </P>
<P>The extended component named <B>NumericTextField </B>is created by extending the <B>TextField </B>class and providing the capability to use <B>key </B>events to filter the characters entered into the <B>NumericTextField </B>object by the user. Only <I>numbers </I>are allowed through the filter. </P>
<P>Although the operation of the new component requires the use of <I>key events</I>, it does not operate on the basis of the <I>Source/Listener</I> mode of the <I>Delegation Event Model</I>. </P>
<P>Rather, <I>key events</I> are enabled on all objects of the class using the <B>enableEvents() </B>method with a <B>KEY_EVENT_MASK</B>. Once this is done, the method named <B>processKeyEvent()</B> is invoked by the runtime system whenever a <I>key event</I> occurs on an object of the class. The method named<B> processKeyEvent()</B> is overridden to provide all of the processing necessary to filter out non-numeric characters without the requirement to instantiate a separate <B>Listener </B>object. </P>
<P>The processing inside the <B>processKeyEvent()</B> method is straightforward. Whenever a <B>KEY_TYPED</B> event occurs, the character typed is intercepted and tested to confirm that it is one of the numeric characters. If not, it is replaced by a character with a zero value. This is not a legal character, so the runtime system beeps and refuses to accept it into the component. </P>
<P>Whenever you override one of the <B>processXxxxEvent()</B> methods, you should always invoke the same method in the superclass passing the event object as a parameter. This makes certain that all necessary default processing takes place. </P>
<P>The program was tested using JDK 1.1 running under Win95. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="interesting_code_fragments"></A>Interesting Code Fragments</H3>
</FONT><P>The first interesting code fragment is the instantiation and adding of an object of the new extended type to the primary GUI <B>Frame </B>object. <br/>
 </P>
<TABLE BORDER CELLSPACING=1 WIDTH=480>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE> NumericTextField myNumericTextField;
 add(myNumericTextField =
 new NumericTextField());//add a custom component</PRE></TD>
</TR>
</TABLE>

<P>The next interesting code fragment is inside the constructor for the new extended component object. Whenever this statement has been executed, <U>any key events</U> that occur on an object of the class are automatically delivered to a method named <B>processKeyEvent()</B>. <br/>
 </P>
<TABLE BORDER CELLSPACING=1>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE> enableEvents(AWTEvent.KEY_EVENT_MASK);</PRE></TD>
</TR>
</TABLE>

<P>Another way of describing the situation is that once the above statement has been executed, the occurrence of a key event on an object of the class will cause a method named <B>processKeyEvent()</B> to be automatically invoked and an event object will be passed to the method as a parameter. This method <U>can be overridden</U> to produce the behavior desired. </P>
<P>The next interesting code fragment shown below is the entire overridden version of the <B>processKeyEvent()</B> method. <br/>
 </P>
<TABLE BORDER CELLSPACING=1 WIDTH=690>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE> protected void processKeyEvent(KeyEvent e){
 if(e.getID() == KeyEvent.<B>KEY_TYPED</B>)//KEY_TYPED is key-down and key-up
 if(!((e.getKeyChar() &gt;= '0') &amp;&amp; (e.getKeyChar() &lt;= '9')))
 e.setKeyChar('\000');
 super.processKeyEvent(e);//always do this when overriding processXxEvent
 }//end processKeyEvent</PRE></TD>
</TR>
</TABLE>

<P>There are a number of different kinds of key events that are delivered to this method. The code in the method ignores all except <B>KEY_TYPED</B>. This is the type of event that occurs when a key has been pressed and released. </P>
<P>There are also a number of methods available to work with the <B>KeyEvent </B>object passed in as a parameter. It is important to note that in this case, processing <U>occurs before</U> the character associated with the key event is actually deposited into the extend <B>TextField </B>object. Therefore, it is <U>possible to intercept</U> the character using the <B>KeyEvent </B>object and modify it before it is deposited. </P>
<P>The logic inside this method simply confirms that the character is a numeric key, and if not, replaces the character by a character having an octal value of '\000'. This is an illegal character insofar as the runtime system is concerned, so the runtime system beeps and refuses to deposit it into the extended <B>TextField </B>object. </P>
<P>This method also invokes the <B>processKeyEvent()</B> method of the <I>superclass </I>passing the event object as a parameter. You must <U>never forget</U> to do this because that method in the superclass performs a number of tasks critical to the overall operation of the system. The requirement to remember to do this is one of the reasons that Sun cautions against using this method of event handling. </P>
<P>The remaining code in the program simply creates some standard <B>Listener </B>classes for copying the data in the new extended component into a <B>Label </B>object, and for terminating the program when the user closes the <B>Frame</B>. </P>
<P>These code fragments have illustrated the <U>essential ingredients</U> of creating an extended component and handling the events for that component without the requirement to instantiate and register <B>Listener </B>objects. A complete listing of the program is contained in the next section. </P>
<FONT COLOR="#ff0000"><H3 ALIGN="CENTER"><A NAME="program_listing"></A>Program Listing</H3>
</FONT><P>This section contains a complete listing of the program. Refer to previous sections for an operational description of the program. <br/>
 </P>
<TABLE BORDER CELLSPACING=1 WIDTH=488>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE>/*File Event29.java Copyright, R.G.Baldwin
This program is designed to be compiled and run under
JDK 1.1

This program illustrates the ability to handle events in
extended components without the requirement to use Listener
objects.

The program extends TextField to create a new type of text
field named NumericTextField. Objects of the new type will
only accept numeric input. If the user attempts to enter
any character other than 0 thru 9, an audible alarm sounds
and the character is not accepted.

The controlling class for the program extends Frame. Thus,
all the GUI action takes place inside a Frame object.

Three component objects are instantiated and added to the
Frame object. One of the objects is an object of the
NumericTextField class described above.

A second object is a standard Button object. The third
object is a Label object.

Whenever the user clicks on the Button, the String data
inside the NumericTextField object is copied into the
Label object.

If the user clicks on the close button on the Frame, the
program terminates.

The custom component named NumericTextField is created by
extending the TextField class and providing the capability
to use key events to filter the characters entered into
the NumericTextField object. Only numbers are allowed
through the filter.

Although the operation of the new component requires the
use of key events, it does not operate on the basis of the
Source/Listener model of the Delegation Event Model.

Rather, key events are enabled on all objects of the class
using the enableEvents() method with a KEY_EVENT_MASK.
Once this is done, the method named processKeyEvent() is
invoked whenever a key event occurs on an object of the
class. The method named processKeyEvent()is overridden to
provide all of the processing necessary to filter out
non-numeric characters without the requirement to
instantiate a separate Listener object.

The processing inside the processKeyEvent() method is
straightforward. Whenever a KEY_TYPED event occurs, the
character typed is intercepted and tested to confirm that
it is one of the numeric characters. If not, it is
replaced by a character with a zero value. This is not a
legal character, so the runtime system beeps and refuses
to accept it into the component.

Whenever you override one of the processXxxxEvent()
methods, you should always invoke the same method in the
superclass passing the event object as a parameter. This
makes certain that all necessary default processing takes
place.

The remaining code consists of a couple of standard
Listener classes. One is used with the Button object to
copy the contents of the NumericTextField object to the
Label object. The other terminates the program when the
user clicks on the close box on the Frame.

The program was tested using JDK 1.1.3 running under Win95.
*/
//=========================================================
import java.awt.*;
import java.awt.event.*;

//=========================================================

public class Event29 extends Frame{
 public static void main(String[] args){
 new Event29();//instantiate an object of this type
 }//end main
//---------------------------------------------------------
 public Event29(){//constructor
 this.setTitle("Copyright, R.G.Baldwin");
 this.setLayout(new FlowLayout());
 this.setSize(250,100);

 Button myButton;
 add(myButton = new Button("Copy to Label"));

 NumericTextField myNumericTextField;
 //add a custom component
 add(myNumericTextField = new NumericTextField());

 Label myLabel;
 add(myLabel = new Label("Initial Text"));

 this.setVisible(true);
 myNumericTextField.requestFocus();

 myButton.addActionListener(
 new MyActionListener(myLabel,myNumericTextField));
 this.addWindowListener(new Terminate());
 }//end constructor

}//end class Event29
//=========================================================

//Class to define a new type of TextField. This is a
// custom TextField component, extended from TextField.
// It will only accept numeric values. Note that it
// depends on key events for its operation but it does not
// use the source/listener mode of the Delegation Event
// Model.
class NumericTextField extends TextField{

 NumericTextField(){//constructor
 this.setColumns(10);//set the size
 //Enable key events so that the processKeyEvent()
 // method will be invoked whenever a key event occurs
 // on an object of this class.
 enableEvents(AWTEvent.KEY_EVENT_MASK);
 }//end constructor
 //-------------------------------------------------------


 //Because key events are enabled, this overridden method
 // will automatically be invoked whenever a key event
 // occurs on an object of the class.
 protected void processKeyEvent(KeyEvent e){
 //KEY_TYPED is key-down and key-up
 if(e.getID() == KeyEvent.KEY_TYPED)
 //If the char is not numeric, substitute an illegal
 // character so that the runtime system will reject
 // it and beep.
 if(!((e.getKeyChar() &gt;= '0')
 &amp;&amp; (e.getKeyChar() &lt;= '9')))
 e.setKeyChar('\000');
 //always do this when overriding processXxEvent
 super.processKeyEvent(e);
 }//end processKeyEvent
}//end class NumericTextField
//=========================================================

//Class to create an ActionListener for the Button object.
// Transfers the data from the NumericTextField to the
// Label.
class MyActionListener implements ActionListener{
 Label myLabel;
 NumericTextField myNumericTextField;
 //-------------------------------------------------------

 MyActionListener( //constructor
 Label inLbl, NumericTextField inNumTxtFld){
 myLabel = inLbl;
 myNumericTextField = inNumTxtFld;
 }//end constructor
 //-------------------------------------------------------

 public void actionPerformed(ActionEvent e){
 myLabel.setText(myNumericTextField.getText());
 }//end actionPerformed()
}//end MyActionListener
//=========================================================

class Terminate extends WindowAdapter{
 public void windowClosing(WindowEvent e){
 //terminate the program when the window is closed
 System.exit(0);
 }//end windowClosing
}//end class Terminate
//=========================================================</PRE></TD>
</TR>
</TABLE>

<FONT COLOR="#ff0000"><H2 ALIGN="CENTER"><A NAME="review"></A>Review</H2>
</FONT><P>Q - Write an application that meets the specifications given below. </P>
<FONT SIZE=2 COLOR="#0000ff"><P>A - See the application that follows:</FONT><br/>
<FONT FACE="Courier New"> </P></FONT>
<TABLE BORDER CELLSPACING=1 WIDTH=486>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#ffff00">
<PRE><FONT COLOR="#0000ff">/*File SampProg131.java Copyright, R.G.Baldwin
This program is designed to be compiled and run under
JDK 1.1

Without viewing the solution that follows, write an
application that contains an object that will accept text
input, a Button object, and a Label object in a standard
frame. For purposes of the remainder of this
specification, the first object listed above will be
referred to as the Text Object.

If you enter lower case letters into the Text Object, they
are automatically converted to upper case before being
displayed.

When you click on the Button, the data inside the Text
Object are copied into the Label object.

When you click on the close button on the Frame, the
program terminates and returns control to the operating
system.

The program was tested using JDK 1.1.3 running under Win95.
*/
//=========================================================
import java.awt.*;
import java.awt.event.*;

//=========================================================

public class SampProg131 extends Frame{
 public static void main(String[] args){
 new SampProg131();//instantiate an object of this type
 }//end main
//---------------------------------------------------------
 public SampProg131(){//constructor
 this.setTitle("Copyright, R.G.Baldwin");
 this.setLayout(new FlowLayout());
 this.setSize(250,100);

 Button myButton;
 add(myButton = new Button("Copy to Label"));

 NumericTextField myCustomTextField;
 //add a custom component
 add(myCustomTextField = new NumericTextField());

 Label myLabel;
 add(myLabel = new Label("Initial Text"));

 this.setVisible(true);

 myButton.addActionListener(
 new MyActionListener(myLabel,myCustomTextField));
 this.addWindowListener(new Terminate());

 }//end constructor

}//end class SampProg131
//=========================================================

//Class to define a new type of TextField. This is a
// custom TextField component, extended from TextField.
// It will only accept numeric values. Note that it
// depends on key events for its operation but it does not
// use the source/listener mode of the Delegation Event
// Model.
class NumericTextField extends TextField{

 NumericTextField(){//constructor
 this.setColumns(10);//set the size
 //Enable key events so that the processKeyEvent()
 // method will be invoked whenever a key event occurs
 // on an object of this class.
 enableEvents(AWTEvent.KEY_EVENT_MASK);
 }//end constructor
 //-------------------------------------------------------


 //Because key events are enabled, this overridden method
 // will automatically be invoked whenever a key event
 // occurs on an object of the class.
 protected void processKeyEvent(KeyEvent e){
 //KEY_TYPED is key-down and key-up
 if(e.getID() == KeyEvent.KEY_TYPED)
 //If the char is lower case, convert it to upper
 // case.
 if(e.getKeyChar() &gt; 'Z')
 e.setKeyChar((char)(e.getKeyChar() -('a' - 'A')));
 //always do this when overriding processXxEvent
 super.processKeyEvent(e);
 }//end processKeyEvent
}//end class NumericTextField
//=========================================================

//Class to create an ActionListener for the Button object.
// Transfers the data from the NumericTextField to the
// Label.
class MyActionListener implements ActionListener{
 Label myLabel;
 NumericTextField myCustomTextField;
 //-------------------------------------------------------

 MyActionListener( //constructor
 Label inLbl, NumericTextField inNumTxtFld){
 myLabel = inLbl;
 myCustomTextField = inNumTxtFld;
 }//end constructor
 //-------------------------------------------------------

 public void actionPerformed(ActionEvent e){
 myLabel.setText(myCustomTextField.getText());
 }//end actionPerformed()
}//end MyActionListener
//=========================================================

class Terminate extends WindowAdapter{
 public void windowClosing(WindowEvent e){
 //terminate the program when the window is closed
 System.exit(0);
 }//end windowClosing
}//end class Terminate
//=========================================================</PRE></FONT></TD>
</TR>
</TABLE>

<P>-end-<!--end--></P></BODY>
</HTML>
