<!--
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
-->
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office">
<head>
<meta content="en-us" http-equiv="Content-Language" />
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />

<title>Streams</title>

<style type="text/css">
a:link {color:#0000ff;}
a:visited {color:#cc00cc;}
a:active {color:#ff0000;}
p{color:black;}
h1{color:black}
h2{color: black}
h3{color: black}
b{color: #000000}
strong{color: #000000}
blockquote{color: black}
ul{color: black}
ol{color: black}
table{border: 1px solid black}
th{border: 1px solid black}
a:hover {
	color: #cc0000;
	font-weight: bold;
	text-decoration: none;
}
.auto-style1 {
	text-align: center;
}
div.a {
  border: 2px solid black;
}

</style>

</head>

<body style="font-family: Arial,Helvetica,sans-serif;font-size: 12pt; background-color: #FEFFFF;"
>





<h1 class="auto-style1">Streams, Default Methods, and Method References</h1>

<h1 class="style1">Table of contents</h1>
<ul>
	<li>
	
    <a href="#Preface">Preface</a></li>
	<li>
	
    <a href="#Introduction_to_inner_classes">Introduction to inner classes</a></li>
	<li>
	
    <a href="#A_quick_introduction_to_generics">Introduction to generics</a></li>
	<li>
	
    <a href="#What_is_a_Java_stream">What is a Java stream?</a></li>
	<li>
	
    <a href="#Default_methods_in_interfaces">Default methods in interfaces</a></li>
	<li>
	
    <a href="#Method_reference_operator">Method reference operator</a></li>
	<li>
	
    <a href="#Sample_code">Sample code</a></li>
	<li>
	
    <a href="#Explanation_of_sample_code">Explanation of sample code</a></li>
	<li>
	
    <a href="#Summary">Summary</a></li>
	<li>
	
    <a href="#Miscellaneous">Miscellaneous</a></li>
	
</ul>
<h3>Some of the text in this eBook was generated by ChatGPT, Google Bard, and 
Bing Chat 
with edits by the author of the eBook.</h3>
	<h2><a name="Preface">Preface</a></h2>
	<p>This lesson demonstrates how to use Java streams. More specifically, it 
	demonstrates how to use Java streams, default methods, and 
	method references to 
			calculate the average value of a list of integers. </p>
<p>It 
			utilizes the <strong>stream</strong>, <strong>mapToDouble</strong>,
	<strong>average</strong>, and <strong>orElse</strong> methods of the <strong>
	Stream</strong> class to perform 
			the necessary operations and handle cases where the list might be 
			empty. </p>
<p>This lesson also provides information on other Java programming 
	features, such as inner classes, that may not be familiar to the reader.</p>
<h2><a name="Introduction_to_inner_classes">Introduction to inner classes</a></h2>
<p>Some of the code that you will in the various lessons of this eBook uses inner 
classes. The purpose of this section is to introduce you to inner classes.</p>
			<p>In Java, an inner class is a class that is defined within another 
			class. It allows you to logically group related classes together and 
			create a more cohesive and encapsulated design. Inner classes have 
			access to the members (variables and methods) of the enclosing 
			class, including its private members. There are several types of 
			inner classes in Java, including nested classes, local classes, and 
			anonymous classes.</p>
			<p>Here are the key points about inner classes:</p>
			<ol>
				<li>
				<p>Nested classes: Nested classes are the most common type of 
				inner classes. They are defined inside another class and can be 
				static or non-static. Static nested classes are similar to 
				regular classes and do not have access to the instance members 
				of the enclosing class. Non-static nested classes, also known as 
				inner classes, have access to both static and non-static members 
				of the enclosing class.</p>
				</li>
				<li>
				<p>Accessing enclosing class members: Inner classes can directly 
				access the members (variables, methods, etc.) of the enclosing 
				class, including private members. This allows for tighter 
				coupling between the inner class and its enclosing class and 
				facilitates information hiding and encapsulation.</p>
				</li>
				<li>
				<p>Enclosing class access from inner class: An inner class can 
				access its enclosing class using the <code>this</code> keyword 
				followed by the name of the enclosing class (<code>this.enclosingClassName</code>). 
				This allows for accessing members of the enclosing class that 
				have the same name as members in the inner class.</p>
				</li>
				<li>
				<p>Local classes: Local classes are defined within a method or a 
				block of code. They have access to the local variables and 
				parameters of the enclosing method or block, but they must be 
				effectively final or final if they are used within the local 
				class.</p>
				</li>
				<li>
				<p>Anonymous classes: Anonymous classes are special types of 
				inner classes that do not have a name. They are typically used 
				for one-time implementations of interfaces or abstract classes. 
				Anonymous classes are defined and instantiated at the same time 
				and are often used for event handling or callbacks.<br/><br/><em>
				Author's note: Anonymous classes are discussed in detail 
				elsewhere in this eBook.</em></p>
				</li>
				<li>
				<p>Benefits of inner classes: Inner classes can improve code 
				organization and encapsulation, especially when the inner class 
				is tightly related to the enclosing class. They allow for better 
				separation of concerns and can make code more readable and 
				maintainable.</p>
				</li>
			</ol>
			<p>Inner classes are a powerful feature in Java that provide a way 
			to logically group related classes and enhance encapsulation. They 
			offer access to the members of the enclosing class and enable a more 
			cohesive design. Inner classes, including nested classes, local 
			classes, and anonymous classes, allow for various levels of 
			encapsulation and code reuse within Java applications.</p>
			<blockquote><em>Author's note: The sample code in the next section uses an inner class.</em></blockquote>
<h2><a name="A_quick_introduction_to_generics">Introduction to generics</a></h2>
<p>Some of the code that you will see in the various lessons of this eBook uses 
generics nomenclature. The purpose of this section is to introduce you to 
generics.</p>
			<p>According to ChatGPT: Generics in Java provide a way to create classes, interfaces, and 
			methods that can operate on different types while maintaining type 
			safety. They allow you to define classes or methods that are 
			parameterized by one or more types, known as type parameters. 
			Generics enable code reusability and ensure compile-time type 
			checking.</p>
			<p>Here are some key points about generics in Java:</p>
			<ol>
				<li>
				<p>Type parameters: Type parameters are placeholders for types 
				that are specified when using generic classes, interfaces, or 
				methods. They are represented within angle brackets (<code>&lt;&gt;</code>) 
				following the class, interface, or method name. For example,
				<code>ArrayList&lt;T&gt;</code> declares a type parameter <code>T</code> 
				for an <code>ArrayList</code> class.</p>
				</li>
				<li>
				<p>Parameterized types: When using a generic class or interface, 
				you provide the actual type arguments for the type parameters. 
				For example, <code>ArrayList&lt;String&gt;</code> specifies the <code>
				String</code> type as the type argument for <code>T</code> in 
				the <code>ArrayList</code> class.</p>
				</li>
				<li>
				<p>Type safety: Generics ensure type safety by performing 
				compile-time type checking. With generics, you can specify the 
				expected types at compile time, which helps detect type-related 
				errors early and avoid runtime type errors.</p>
				</li>
				<li>
				<p>Reusability: Generics enable code reusability by allowing the 
				creation of generic classes, interfaces, and methods that can 
				work with different types. This avoids the need for duplicating 
				code for similar functionality with different types.</p>
				</li>
				<li>
				<p>Generic classes: Generic classes are classes that have one or 
				more type parameters. They can be used to create objects that 
				operate on different types. For example, <code>ArrayList&lt;T&gt;</code> 
				is a generic class that can hold elements of any type <code>T</code>.</p>
				</li>
				<li>
				<p>Generic interfaces: Similar to generic classes, generic 
				interfaces have type parameters and can be implemented by 
				classes or other interfaces with different types. For example, 
				the <code>Comparator&lt;T&gt;</code> interface can be implemented to 
				compare objects of any type <code>T</code>.</p>
				</li>
				<li>
				<p>Generic methods: Generic methods are methods that introduce 
				their own type parameters. They can be used within generic 
				classes or independently. Generic methods allow you to 
				parameterize a method based on its input and output types, 
				making it flexible and reusable.</p>
				</li>
				<li>
				<p>Wildcards: Wildcards (<code>?</code>) are used when you want 
				to operate on an unknown type within generics. There are two 
				wildcard types: <code>? extends Type</code> (upper bounded 
				wildcard) and <code>? super Type</code> (lower bounded 
				wildcard). Wildcards provide flexibility when working with 
				unknown types without compromising type safety.</p>
				</li>
			</ol>
			<p>Generics in Java offer a powerful way to create flexible, 
			reusable, and type-safe code. They allow you to create generic 
			classes, interfaces, and methods that can work with different types, 
			providing compile-time type checking and reducing the need for code 
			duplication.</p>
<p>Here's a simple Java program that demonstrates generics and their 
nomenclature:</p>
<div class="a">
<pre>public class GenericsDemo&lt;T&gt; {
    private T genericField;

    public T getGenericField() {
        return genericField;
    }

    public void setGenericField(T value) {
        genericField = value;
    }

    public static void main(String[] args) {
        GenericsDemo&lt;Integer&gt; integerDemo = new GenericsDemo&lt;&gt;();
        integerDemo.setGenericField(42);
        Integer intValue = integerDemo.getGenericField();
        System.out.println("Integer value: " + intValue);

        GenericsDemo&lt;String&gt; stringDemo = new GenericsDemo&lt;&gt;();
        stringDemo.setGenericField("Hello, Generics!");
        String stringValue = stringDemo.getGenericField();
        System.out.println("String value: " + stringValue);
    }
}</pre>
</div>
<p>Explanation:</p>
<ol>
	<li>
	<p>The program defines a generic class called <code>GenericsDemo</code> with 
	a type parameter <code>T</code>. The class has a private field named <code>
	genericField</code> of type <code>T</code>.</p>
	</li>
	<li>
	<p>The <code>getGenericField</code> method returns the value of <code>
	genericField</code>, and the <code>setGenericField</code> method sets the 
	value of <code>genericField</code> based on the provided argument.</p>
	</li>
	<li>
	<p>In the <code>main</code> method, we create an instance of <code>
	GenericsDemo</code> with the type parameter <code>Integer</code> using the 
	syntax <code>GenericsDemo&lt;Integer&gt; integerDemo = new GenericsDemo&lt;&gt;()</code>. 
	This means that <code>genericField</code> will be of type <code>Integer</code>.<br/>
	<br/><em>Author's note: This is an example of an inner class.</em></p>
	</li>
	<li>
	<p>We then set the value of <code>genericField</code> using <code>
	integerDemo.setGenericField(42)</code>, passing an <code>Integer</code> 
	value.</p>
	</li>
	<li>
	<p>We retrieve the value of <code>genericField</code> using <code>
	integerDemo.getGenericField()</code>, which returns an <code>Integer</code>, 
	and assign it to the <code>intValue</code> variable.</p>
	</li>
	<li>
	<p>Finally, we print the value of <code>intValue</code> to the console.</p>
	</li>
	<li>
	<p>Next, we create another instance of <code>GenericsDemo</code> with the 
	type parameter <code>String</code> using <code>GenericsDemo&lt;String&gt; 
	stringDemo = new GenericsDemo&lt;&gt;()</code>.</p>
	</li>
	<li>
	<p>We set the value of <code>genericField</code> using <code>
	stringDemo.setGenericField("Hello, Generics!")</code>, passing a <code>
	String</code> value.</p>
	</li>
	<li>
	<p>We retrieve the value of <code>genericField</code> using <code>
	stringDemo.getGenericField()</code>, which returns a <code>String</code>, 
	and assign it to the <code>stringValue</code> variable.</p>
	</li>
	<li>
	<p>Finally, we print the value of <code>stringValue</code> to the console.</p>
	</li>
</ol>
<p>In this example, the use of generics allows us to create a single class <code>
GenericsDemo</code> that can work with different types (<code>Integer</code> and
<code>String</code> in this case). The type parameter <code>T</code> is used to 
indicate the type of the <code>genericField</code>, and it is specified when 
creating instances of <code>GenericsDemo</code>. This ensures type safety and 
enables the code to be reusable for different types without the need for 
duplicating the class implementation.</p>
	<h2><a name="What_is_a_Java_stream">What is a Java stream?</a></h2>

<h3>The following explanation was generated by ChatGPT</h3>
<p>Streams were added to Java in version 8 along with several other 
	features. A
	<a href="https://www.w3resource.com/java-exercises/stream/index.php">stream</a> is a sequence of elements from a source that supports aggregate operations. 
</p>
<ul>
	<li>Sequence of elements: A stream provides an interface to a sequenced set of values of a specific element type. However, streams don’t actually store elements; they are computed on demand.
    </li>
	<li>Source: Streams consume from a data-providing source such as collections, arrays, or I/O resources.
    </li>
	<li>Aggregate operations: Streams support SQL-like operations and common operations from functional programing languages, such as filter, map, reduce, find, match, sorted, and so on.
	</li>
</ul>
<p>According to ChatGPT: In Java 8, the Stream API was introduced as a new abstraction for processing data in a functional and declarative way. A stream can be thought of as a sequence of elements that can be processed in parallel or sequentially. Streams allow you to perform various operations on the elements, such as filtering, mapping, sorting, and reducing. </p>
<p>Here are some key concepts and features of streams in Java 8:

    </p>
<ol>
	<li>Data Source: A stream gets its input from a data source, which can be a collection, an array, an I/O channel, or even a generator function.

    </li>
	<li>Functional Operations: Streams provide a set of functional operations that can be chained together to form a pipeline. These operations are divided into two types: intermediate operations and terminal operations.

        <ol>
			<li>Intermediate Operations: These operations transform a stream into another stream. Some common intermediate operations include filter, map, flatMap, sorted, distinct, and limit. Intermediate operations are lazily evaluated, meaning they are not executed until a terminal operation is invoked.

        	</li>
			<li>Terminal Operations: These operations produce a result or a side-effect. They trigger the processing of the stream and cannot be further chained. Examples of terminal operations include forEach, toArray, collect, reduce, min, max, anyMatch, allMatch, noneMatch, and count.

    		</li>
	</ol>
	</li>
	<li>Lazy Evaluation: Streams support lazy evaluation, which means that the elements are processed on-demand. Intermediate operations are only executed when a terminal operation is encountered. This allows for optimized and efficient processing by avoiding unnecessary computations.

    </li>
	<li>Pipelining: Multiple operations can be combined together to form a pipeline, where the output of one operation becomes the input of the next operation. This enables concise and expressive code.

    </li>
	<li>Parallel Processing: Streams can be processed in parallel to leverage multi-core architectures and improve performance. The parallel() method can be used to convert a sequential stream into a parallel stream. However, parallel processing may not always be beneficial and should be used judiciously based on the nature of the data and the operations being performed.

	</li>
</ol>
<p>Streams provide a powerful and expressive way to process collections and other data sources in Java 8 and later versions. They promote functional programming principles, improve code readability, and offer better performance optimization opportunities compared to traditional iterative approaches.</p>
<h3>The following explanation was generated by Microsoft Bing Chat</h3>

	<p>Java 8 introduced the Stream API which is used to process collections of objects. A stream is a sequence of objects that supports various methods which can be pipelined to produce the desired result. The features of Java stream are:

	</p>
<ul>
	<li>A stream is not a data structure. Instead it takes input from the Collections, Arrays or I/O channels.
	</li>
	<li>Streams don’t change the original data structure, they only provide the result as per the pipelined methods.
	</li>
	<li>Each intermediate operation is lazily executed and returns a stream as a result, hence various intermediate operations can be pipelined. Terminal operations mark the end of the stream and return the result.
	</li>
	<li>Operations performed on a stream does not modify it, instead they create a new stream.
	</li>
	<li>Streams can be processed sequentially or in parallel. </li>
</ul>
<h3>The following explanation was generated by Google Bard:</h3>
<p>Java 8 introduced a new stream API that allows developers to process data in a declarative way. Streams are a new abstract layer that sits on top of the existing collections framework. They provide a way to process data without having to worry about the underlying storage mechanism.

</p>
<p>Streams are composed of a source, zero or more intermediate operations, and a terminal operation. The source can be a collection, an array, or an I/O channel. The intermediate operations allow you to filter, map, and transform the data. The terminal operation performs the actual processing of the data.

</p>
<p>Streams are lazy, which means that they are not evaluated until you perform a terminal operation. This can lead to significant performance improvements, especially for large datasets.

</p>
<p>Streams are also parallelizable, which means that they can be processed on multiple cores simultaneously. This can further improve performance for large datasets.

</p>
<h2><a name="Default_methods_in_interfaces">Default methods in interfaces</a></h2>
<p>A sample program that illustrates streaming will be presented a little later. In order to understand that code, you will need to 
understand the use of default methods in interfaces.</p>
<p>According to ChatGPT: Default methods in Java interfaces were introduced in Java 8 as 
a new feature. They allow interfaces to provide a default implementation for a 
method. Prior to Java 8, interfaces could only declare method signatures without 
providing any implementation.</p>
<p>Here are the key characteristics and use cases of default methods in Java 
interfaces:</p>
<ol>
	<li>
	<p>Default Method Declaration: A default method is declared in an interface 
	by using the <code>default</code> keyword before the method signature. The 
	method body is provided within the interface itself.</p>
	</li>
	<li>
	<p>Default Implementation: Unlike regular interface methods, default methods 
	have a default implementation. This means that the method provides a 
	predefined behavior that is automatically inherited by implementing classes. 
	Implementing classes are not required to provide an implementation for 
	default methods unless they choose to override them.</p>
	</li>
	<li>
	<p>Adding Methods to Existing Interfaces: Default methods were primarily 
	introduced to support backward compatibility when adding new methods to 
	existing interfaces. With default methods, new methods can be added to an 
	interface without breaking the existing code that implements that interface.</p>
	</li>
	<li>
	<p>Providing Default Behavior: Default methods allow interfaces to define a 
	default behavior for methods. Implementing classes can inherit the default 
	implementation and override it if needed. This helps reduce boilerplate code 
	in implementing classes.</p>
	</li>
	<li>
	<p>Multiple Inheritance: Default methods play a significant role in 
	supporting multiple inheritance of behavior in Java interfaces. If a class 
	implements multiple interfaces with the same default method, the 
	implementing class can choose to use the default implementation from one 
	interface or override it with its own implementation.</p>
	</li>
</ol>
<blockquote><blockquote></blockquote></blockquote>
<h2><a name="Method_reference_operator">Method reference operator</a></h2>
<p>As mentioned earlier, a sample program that illustrates streaming 
will be presented and explained a little later. First, however, there is a need to present and discuss an operator that 
you may not be familiar with: the method reference operator (::).</p>
<p>According to ChatGPT: In Java, the <code>::</code> operator is known as the method reference 
operator. It is used to create a reference to a method or a constructor that can 
be stored in a functional interface or used in lambda expressions. The <code>::</code> 
operator allows you to treat a method as a first-class object.</p>
<blockquote><p><em>Author's note: Functional interfaces and lambda expressions 
	are discussed elsewhere in this eBook.</em></p></blockquote>
<p>There are different forms of method references in Java, depending on the type 
of method being referenced and the context in which it is used:</p>
<ol>
	<li>Reference to a Static Method: You can use the <code>::</code> operator 
	to reference a static method defined in a class or interface. The syntax is
	<code>ClassName::methodName</code>. </li>
	<li>Reference to an Instance Method of an Object: You can reference an 
	instance method of an existing object using the <code>::</code> operator. 
	The syntax is <code>objectReference::methodName</code>.</li>
	<li>Reference to an Instance Method of a Class: You can use the <code>::</code> 
	operator to reference an instance method of a class or interface when you 
	don't have an existing object. The syntax is <code>ClassName::methodName</code>.&nbsp; </li>
	<li>Reference to a Constructor: The <code>::</code> operator can also be 
	used to reference a constructor. The syntax is <code>ClassName::new</code>.</li>
</ol>
<h2><a name="Sample_code">Sample code</a></h2>
<p>The following
code 
illustrates the use of Java streams. </p>
<div class="a">
	<pre>

import java.util.Arrays;
import java.util.List;

public class IntegersAverage {
  public static void main(String[] args) {
    List < Integer > nums = Arrays.asList(1, 3, 6, 8, 10, 18, 36);
    System.out.println("List of numbers: " + nums);

    // Calculate the average using streams
    double average = nums.stream()
      .mapToDouble(Integer::doubleValue)
      .average()
      .orElse(0.0);

    System.out.println("Average value of the said numbers: " + average);
  }// end main
}//end class IntegersAverage
</pre>
</div>
<h2><a name="Explanation_of_sample_code">Explanation of sample code</a></h2>
			<p>According to ChatGPT: The given code calculates the average value of a list of integers 
			using Java streams. Here's a step-by-step explanation of how it 
			works:</p>
			<ol>
				<li>
				<p>The code begins by importing the necessary classes: <code>
				List</code> from <code>java.util</code> and <code>Arrays</code> 
				from <code>java.util.Arrays</code>.</p>
				</li>
				<li>
				<p>The <code>IntegersAverage</code> class is defined as a public 
				class.</p>
				</li>
				<li>
				<p>The <code>main</code> method is declared as the entry point 
				of the program.</p>
				</li>
				<li>
				<p>Inside the <code>main</code> method, a list of integers named
				<code>nums</code> is created using the <code>Arrays.asList</code> 
				method. The list contains the values 1, 3, 6, 8, 10, 18, and 36.<br/>
				<br/>
				
				<em>Author's note: When whole number (integer) values are added 
				to a <strong>List</strong> object, they are stored as references to objects of 
				the class <strong>Integer</strong>. They are not stored as the primitive type 
				<strong>integer</strong>. </em>
				
				</p>
				</li>
				<li>
				<p>The list of numbers is printed using <code>
				System.out.println("List of numbers: " + nums);</code>.</p>
				</li>
				<li>
				<p>The average value of the numbers is calculated using streams. 
				Here's how it is done:</p>
				<ul>
					<li>The <code>nums</code> list is converted into a stream 
					using the <code>stream()</code> method.<br/><br/><em>Author's 
					note: The actual type of the <strong>nums</strong> list isn't obvious from 
					the documentation. However, I was able to determine 
					experimentally that the object is of type 
					<strong>java.util.Arrays$ArrayList</strong>. <br/><br/>
					According to ChatGPT: "In Java, <code>
					java.util.Arrays$ArrayList</code> is a class that represents 
					a fixed-size list backed by an array. It is a nested class 
					within the <code>java.util.Arrays</code> class, and it 
					provides an implementation of the <code>java.util.List</code> 
					interface." <br/><br/>Author's note: The <strong>java.util.List</strong> 
					interface extends the <strong>Collection</strong> interface, which defines 
					the <strong>stream</strong> method as a default method. The
					<strong>stream</strong> method 
					"Returns a sequential Stream with this collection as its 
					source." <br/><br/></em></li>
					<li>The <code>mapToDouble</code> operation is applied to 
					convert each <code>Integer</code> in the stream to its 
					corresponding <code>double</code> value using <code>
					Integer::doubleValue</code> method reference.<br/><br/><em>
					Author's note: The <strong>mapToDouble
					</strong>method is a default method of 
					the <strong>Stream</strong> interface. It returns an object of the interface 
					type <strong>DoubleStream</strong>. The :: method reference operator 
					instructs the <strong>mapToDouble</strong> method to use the 
					<strong>doubleValue</strong> 
					method of the <strong>Integer</strong> class to make the conversion. <br/>
					</em><br/></li>
					<li>The <code>average()</code> operation is then called on 
					the stream to calculate the average of the converted <code>
					double</code> values.<br/><br/><em>Author's note: The <strong>
					average</strong> method of the <strong>DoubleStream</strong> object is used to 
					compute the average of all of the values in the stream, 
					returning an object of the class type <strong>OptionalDouble</strong>. The 
					<strong>OptionalDouble</strong> object is a container that may or may not 
					contain an object of type <strong>double</strong>.</em><br/><br/></li>
					<li>Finally, the <code>orElse(0.0)</code> method is used to 
					provide a default value of 0.0 if the stream is empty.<br/>
					<br/><em>Author's note: The <strong>orElse(0.0) </strong>method is called 
					on the <strong>OptionalDouble</strong> object to determine what value to 
					return. If the <strong>OptionalDouble</strong> container object contains a 
					<strong>double</strong> object, it is returned and stored in the variable 
					named <strong>average</strong>. If that container object is empty, a 
					<strong>double</strong> 
					value of 0.0 is returned and stored in the variable named 
					average. That terminates the processing of the stream.</em><br/></li>
				</ul>
				</li>
				<li>
				<p>The calculated average is stored in the <code>average</code> 
				variable of type <code>double</code>.</p>
				</li>
				<li>
				<p>The average value is printed using <code>
				System.out.println("Average value of the said numbers: " + 
				average);</code>.</p>
				</li>
				<li>
				<p>The <code>main</code> method and the <code>IntegersAverage</code> 
				class are closed with closing braces.</p>
				</li>
			</ol>
			<p>Overall, the code demonstrates how to use Java streams to 
			calculate the average value of a list of integers efficiently. It 
			utilizes the <code>stream()</code>, <code>mapToDouble()</code>,
			<code>average()</code>, and <code>orElse()</code>  methods to perform 
			the necessary operations and handle cases where the list might be 
			empty.</p>
<h2><a name="Summary">Summary</a></h2>
<p>This lesson has used text from ChatGPT, Bard, and Bing Chat in an attempt to 
explain and demonstrate how to use Java streams. </p>
<p>In particular, the lesson 
	provides and explains a program that demonstrates how to use Java streams, default methods, and 
	method references to 
			calculate the average value of a list of integers. </p>
<p>The program uses the <strong>stream</strong>, <strong>mapToDouble</strong>,
	<strong>average</strong>, and <strong>orElse</strong> methods of the <strong>
	Stream</strong> class to perform 
			the necessary operations and handle cases where the list might be 
			empty. </p>
<p>This lesson also provides information on other Java programming 
	features, such as inner classes, that may not be familiar to the reader.</p>
	<h2><a name="Miscellaneous">Miscellaneous</a></h2>
	<p>This section contains a variety of miscellaneous information.</p>

<!--Set border to 15 to create a note. Paragraph elements inside the note are allowed but not required.-->
<div class="a">
	<p><strong>Housekeeping material</strong>
				</p>
				<ul>
					<li>Author: Prof. Richard G. Baldwin</li>
					<li>Lesson title: Streams, Default Methods, and Method References</li>
					<li>File: Streams01.htm</li>
					<li>Published: 06/16/23</li>
				</ul>
</div>

<!--Set border to 15 to create a note. Paragraph elements inside the note are allowed but not required.-->
	<p>-end- </p>
<p>&nbsp;</p>


</body>
</html>