<!--
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
-->
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office">
<head>
<meta content="en-us" http-equiv="Content-Language" />
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />

<title>Functional Interface</title>

<style type="text/css">
a:link {color:#0000ff;}
a:visited {color:#cc00cc;}
a:active {color:#ff0000;}
p{color:black;}
h1{color:black}
h2{color: black}
h3{color: black}
b{color: #000000}
strong{color: #000000}
blockquote{color: black}
ul{color: black}
ol{color: black}
table{border: 1px solid black}
th{border: 1px solid black}
a:hover {
	color: #cc0000;
	font-weight: bold;
	text-decoration: none;
}
.auto-style1 {
	text-align: center;
}
div.a {
  border: 2px solid black;
}

.auto-style2 {
	font-family: "Courier New", Courier, monospace;
}

</style>

</head>

<body style="font-family: Arial,Helvetica,sans-serif;font-size: 12pt; background-color: #FEFFFF;"
>





<h1 class="auto-style1">Functional Interfaces</h1>

<h2>Table of contents</h2>
<ul>
	<li>
	
    <a href="#Preface">Preface</a></li>
	<li>
	
    <a href="#What_is_an_anonymous_class">What is an anonymous class?</a></li>
	<li>
	
    <a href="#What_is_an_interface">What is an interface?</a></li>
	<li>
	
    <a href="#What_is_a_functional_interface">What is a functional interface?</a></li>
	<li>
	
    <a href="#Summary">Summary</a></li>
	<li>
	
    <a href="#Miscellaneous">Miscellaneous</a></li>
    
</ul>
<h3>Some of the text in this eBook was generated by ChatGPT, Google Bard, and 
Bing Chat with edits by the author of the eBook.</h3>
<h2><a name="Preface">Preface</a></h2>
	<p>This lesson explains and demonstrates how to use functional interfaces. It 
	also explains some other Java features that are important in understanding 
	functional interfaces but which may not be familiar to the reader.</p>
<h2><a name="What_is_an_anonymous_class">What is an anonymous class?</a></h2>
<h4>Prompt: Explain anonymous classes.</h4>

<blockquote><em>Author's note: This information is provided to help you 
understand the explanation of code that implements the <strong>java.util.function.Function</strong> 
	interface later in this lesson.</em></blockquote>
<p>In Java, an anonymous class is a class that is defined and instantiated at 
the same time without explicitly giving it a name. It allows you to define a 
class "on the fly" when you need it without having to create a separate named 
class. Anonymous classes are often used when you need to create a one-time 
implementation of an interface or a subclass of a class.</p>

<p>Here are some key points about anonymous classes:</p>
<ol>
	<li>
	<p>Syntax: The syntax for creating an anonymous class is as follows:
 
<br/><br/><span class="auto-style2">SuperType instanceName = new SuperType(constructor arguments) {
    <br/>&nbsp;&nbsp; // Anonymous class body
<br/>};</span>




</p>
	</li>
	<li>
	<p>Here, <code>SuperType</code> can be an interface or a class that you are 
	extending, and the anonymous class body contains the implementation of 
	methods or additional members.</p>
	</li>
	
	
	<li>
	<p>No explicit class name: Anonymous classes don't have a class name 
	associated with them. Instead, the class is defined inline and assigned to a 
	variable or used directly.</p>
	</li>
	<li>
	<p>Instantiation: The anonymous class is instantiated with the <code>
	<strong>new</strong></code> 
	keyword, just like regular class instances. The anonymous class can have 
	constructor arguments if the superclass has one or more constructors.</p>
	</li>
	<li>
	<p>Override methods: Anonymous classes are commonly used to implement 
	interfaces or override methods of a superclass. Inside the anonymous class 
	body, you can provide implementations for the methods defined by the 
	interface or superclass.</p>
	</li>
	<li>
	<p>Local scope: Anonymous classes are typically defined within a method or 
	as part of an expression and have access to local variables and parameters 
	of that method. However, they can only access <code>final</code> or 
	effectively final variables.</p>
	</li>
	<li>
	<p>Limited reusability: Anonymous classes are suitable for one-time use and 
	are not meant to be reused elsewhere in the code. If you need to reuse the 
	class definition, it's better to define a named class instead.</p>
	</li>
	<li>
	<p>Concise syntax: Anonymous classes can provide a more concise syntax 
	compared to creating a separate named class, especially for small and simple 
	implementations.</p>
	</li>
</ol>
<p>Anonymous classes are commonly used in Java for event handling, callback 
functions, and providing quick implementations of interfaces or abstract 
classes. They offer a convenient way to create a class "on the fly" without the 
need for defining a separate class with a name.</p>

	<h2><a name="What_is_an_interface">What is an interface?</a></h2>
<p>The material in this section is 
presented to help you understand the explanation of functional interfaces later.</p>
						<h4>Prompt: Explain interfaces in Java.</h4>
<p>According to ChatGPT: In Java, interfaces are an essential part of the 
						language and play a crucial role in defining contracts, 
						enabling polymorphism, and promoting code reusability. 
						Here are some key uses of interfaces in Java:</p>
						<ol>
							<li>
							<p>Defining Contracts: Interfaces serve as contracts 
							that define a set of methods that implementing 
							classes must adhere to. By specifying the methods 
							that a class must implement, interfaces establish a 
							clear contract for how objects can interact with 
							each other. This allows for better code organization 
							and design.</p>
							</li>
							<li>
							<p>Achieving Polymorphism: Java supports 
							polymorphism, which allows objects of different 
							classes to be treated interchangeably through a 
							common interface. By programming to interfaces 
							rather than specific classes, you can write code 
							that is more flexible and adaptable. This 
							flexibility is especially useful when working with 
							collections, frameworks, and designing extensible 
							systems.</p>
							</li>
							<li>
							<p>Enabling Multiple Inheritance of Types: Unlike 
							classes, which can only inherit from a single 
							superclass, a class in Java can implement multiple 
							interfaces. This feature allows a class to inherit 
							the behavior specified by multiple interfaces, 
							providing a mechanism for achieving multiple 
							inheritance of types.</p>
							</li>
							<li>
							<p>Promoting Code Reusability: Interfaces promote 
							code reuse by defining a common set of methods that 
							can be implemented by multiple classes. This allows 
							you to write code that is not tightly coupled to 
							specific implementations but instead relies on the 
							interface. By programming to interfaces, you can 
							write generic code that works with different 
							implementations, making your code more modular and 
							reusable.</p>
							</li>
							<li>
							<p>Providing Callback Mechanisms: Interfaces are 
							commonly used to define callback mechanisms in Java. 
							For example, in event-driven programming or 
							listener-based architectures, interfaces define the 
							callback methods that are invoked when specific 
							events occur. Implementing these interfaces allows 
							your classes to respond to events and provide custom 
							behavior.</p>
							</li>
							<li>
							<p>Supporting APIs and Frameworks: Many Java APIs 
							and frameworks extensively use interfaces to define 
							contracts and provide extension points. By 
							implementing these interfaces, developers can 
							leverage the functionality provided by the APIs or 
							frameworks and customize the behavior according to 
							their specific requirements.</p>
							</li>
						</ol>
						<p>Overall, interfaces in Java serve as powerful tools 
						for abstraction, defining contracts, achieving 
						polymorphism, and promoting code reusability. They play 
						a fundamental role in the design and implementation of 
						Java programs and are widely used in various application 
						domains.</p>
			<h4>Prompt: Provide and explain a Java program that uses an interface for 
			polymorphism.</h4>



						<p>Certainly! Here's an example of a Java program that 
						demonstrates polymorphism using an interface:</p>
<div class="a">
			<pre>// Animal interface
interface Animal {
    void makeSound();
}

// Dog class implementing Animal interface
class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Dog barks!");
    }
}

// Cat class implementing Animal interface
class Cat implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Cat meows!");
    }
}

// Main class
public class PolymorphismExample {
    public static void main(String[] args) {
        // Create an array of Animal references
        Animal[] animals = new Animal[2];

        // Assign Dog and Cat instances to Animal references
        animals[0] = new Dog();
        animals[1] = new Cat();

        // Iterate over the array and make each animal sound
        for (Animal animal : animals) {
            animal.makeSound();
        }
    }
}
</pre>
</div>
			<p>According to ChatGPT: In this program, we have an interface called <code>Animal</code>, 
			which defines the <code>makeSound()</code> method as a common 
			behavior for animals.</p>
			<p>The <code>Dog</code> class and the <code>Cat</code> class both 
			implement the <code>Animal</code> interface and provide their own 
			implementation of the <code>makeSound()</code> method.</p>
			<p>In the <code>main()</code> method of the <code>
			PolymorphismExample</code> class, we create an array of <code>Animal</code> 
			references. We assign instances of <code>Dog</code> and <code>Cat</code> 
			to those references, taking advantage of polymorphism. Since both
			<code>Dog</code> and <code>Cat</code> implement the <code>Animal</code> 
			interface, they can be treated as <code>Animal</code> objects.</p>
			<p>We then iterate over the array of <code>Animal</code> references 
			and call the <code>makeSound()</code> method on each object. At 
			runtime, the appropriate <code>makeSound()</code> method 
			implementation of each object (either <code>Dog</code> or <code>Cat</code>) 
			is invoked based on its actual type.</p>
			<p>As a result, when the program is executed, it will output:</p>

			<pre>Dog barks!
Cat meows!
</pre>
			<p>This example demonstrates polymorphism through the use of an 
			interface. By programming to the <code>Animal</code> interface, we 
			can store different implementations of <code>Animal</code> (in this 
			case, <code>Dog</code> and <code>Cat</code>) in a common array of
			<code>Animal</code> references. This allows us to treat each object 
			uniformly and invoke the appropriate behavior based on its actual 
			type, achieving polymorphic behavior.</p>
<h2><a name="What_is_a_functional_interface">What is a functional interface?</a></h2>
			<h4>Prompt: Explain functional interfaces in java.</h4>
			<p>In Java, a functional interface is an interface that contains 
			only one abstract method. It is often associated with lambda 
			expressions and functional programming concepts. The introduction of 
			functional interfaces in Java 8 was a significant addition to the 
			language, as it enabled the use of lambda expressions and provided a 
			more concise way to write code.</p>
			<blockquote><em>Author's note: Lambda expressions are discussed elsewhere in 
			this eBook.</em></blockquote>
			<p>Here are some key points about functional interfaces in Java:</p>
			<ol>
				<li>
				<p>Single Abstract Method (SAM) Interface: A functional 
				interface must have exactly one abstract method. It can also 
				contain default methods, static methods, and other methods from 
				the <code>Object</code> class, but only one abstract method is 
				allowed.</p>
				</li>
				<li>
				<p>Lambda Expressions: Functional interfaces are primarily used 
				with lambda expressions, which allow you to write more compact 
				and expressive code. Lambda expressions provide a way to 
				implement the single abstract method defined in the functional 
				interface.</p>
				</li>
				<li>
				<p><code>@FunctionalInterface</code> Annotation: While it is not 
				mandatory to use the <code>@FunctionalInterface</code> 
				annotation, it is good practice to use it for functional 
				interfaces. This annotation ensures that the interface has only 
				one abstract method. If more than one abstract method is defined 
				or added later, the compiler will report an error.</p>
				</li>
				<li>
				<p>Predefined Functional Interfaces: Java provides several 
				predefined functional interfaces in the <code>java.util.function</code> 
				package. These interfaces serve as building blocks for 
				functional programming and cover common use cases. Some examples 
				include <code>Predicate</code>, <code>Function</code>, <code>
				Consumer</code>, and <code>Supplier</code>.<br/><br/><em>
				Author's note: A sample program that illustrates the predefined 
				Function interface is presented later in this lesson.</em></p>
				</li>
				<li>
				<p>Custom Functional Interfaces: You can create your own 
				functional interfaces by defining a single abstract method and 
				using the <code>@FunctionalInterface</code> annotation. These 
				custom functional interfaces can be tailored to suit specific 
				requirements and used with lambda expressions.</p>
				</li>
			</ol>
			<p>Functional interfaces provide a powerful mechanism for writing 
			concise and readable code in Java, especially in scenarios where you 
			need to pass behavior as a parameter or return it from a method. 
			They promote the functional programming paradigm and enable you to 
			leverage the benefits of lambda expressions and method references in 
			your Java programs.</p>
<h4>Prompt: Provide an example of a functional interface that contains all 
possible kinds of methods, abstract, default, etc.</h4>
<p>Here's an example of a functional interface called <code>
AllMethodsFunctionalInterface</code> that contains various kinds of methods, 
including abstract methods, default methods, and static methods:</p>
<div class="a">
<pre>@FunctionalInterface
public interface AllMethodsFunctionalInterface {
    // Abstract method
    void abstractMethod();

    // Default method
    default void defaultMethod() {
        System.out.println("This is a default method.");
    }

    // Another default method
    default void anotherDefaultMethod() {
        System.out.println("This is another default method.");
    }

    // Static method
    static void staticMethod() {
        System.out.println("This is a static method.");
    }
}
</pre>
</div>
<p>In this example, <code>AllMethodsFunctionalInterface</code> is annotated with
<code>@FunctionalInterface</code>, indicating that it is intended to be a 
functional interface. It contains the following types of methods:</p>
<ol>
	<li>
	<p>Abstract method: The <code>abstractMethod()</code> has no implementation 
	and must be overridden by any class that implements this functional 
	interface.</p>
	</li>
	<li>
	<p>Default methods: The <code>defaultMethod()</code> and <code>
	anotherDefaultMethod()</code> methods have default implementations within 
	the interface itself. These methods can be overridden by implementing 
	classes, but they are not required to do so.</p>
	</li>
	<li>
	<p>Static method: The <code>staticMethod()</code> is a static method defined 
	within the interface itself. Static methods can be invoked directly on the 
	interface, without the need for an instance of a class that implements the 
	interface.</p>
	</li>
</ol>
<p>By combining these different types of methods, this example demonstrates the 
flexibility of functional interfaces in Java.</p>
<h4>Prompt: Provide a sample program that doesn't involve lambda expressions.</h4>
<p>Certainly! Here's a sample program that demonstrates the use of a functional 
interface without lambda expressions:</p>
<div class="a">
<pre>// Functional interface
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
}

// Implementation of the functional interface
class Addition implements Calculator {
    @Override
    public int calculate(int a, int b) {
        return a + b;
    }
}

// Main class
public class FunctionalInterfaceExample {
    public static void main(String[] args) {
        // Create an instance of the implementation class
        Calculator calculator = new Addition();
        
        // Use the functional interface to perform addition
        int result = calculator.calculate(5, 3);
        
        // Print the result
        System.out.println("Result: " + result);
    }
}
</pre>
</div>
<p>According to ChatGPT: In this example, we have a functional interface called <code>Calculator</code>, 
which defines the <code>calculate()</code> method for performing calculations. 
</p>
<blockquote><em>Author's note: Sometimes these AI bots make mistakes. In this case it 
	might be more appropriate to say that the interface declares the method 
signature for an abstract method named <strong>calculate. </strong>Note also 
that unlike with a class, it is not necessary to declare an abstract method 
signature in an interface with the keyword <strong>abstract</strong>. This is a 
holdover from a previous time when an interface could only contain abstract 
method signatures. </em></blockquote>
<p>The <code>Addition</code> class implements this interface and provides the 
implementation for the <code>calculate()</code> method.</p>
<blockquote><em>Author's note: The </em><strong><em>addition</em></strong><em> method 
actually defines a concrete version of the </em><strong><em>calculate</em></strong><em> 
method by overriding the abstract method signature and providing a body for the 
method.</em></blockquote>
<p>In the <code>main()</code> method of the <code>FunctionalInterfaceExample</code> 
class, we create an instance of the <code>Addition</code> class and assign it to 
the <code>Calculator</code> interface. </p>
<blockquote><em>Author's note: It might be more appropriate to say that we 
create an instance of the </em><strong><em>addition</em></strong><em> class and 
assign it to the reference variable named </em><strong><em>calculator</em></strong><em>, 
which is of the interface type </em><strong><em>Calculator</em></strong>.</blockquote>
<p>We then use the functional interface 
reference (<code>calculator</code>) to call the <code>calculate()</code> method, 
passing in two integers (5 and 3) to perform the addition. Finally, we print the 
result to the console.</p>
<p>Although this example doesn't involve lambda expressions, it demonstrates the 
use of a functional interface to provide a common interface for different 
calculation operations.</p>
<h4>Prompt: How does this differ from an ordinary interface?</h4>
<div class="flex flex-grow flex-col gap-3">
	<div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap break-words">
		<div class="markdown prose w-full break-words dark:prose-invert light">
			<p>An ordinary interface in Java can have multiple abstract methods, 
			whereas a functional interface is limited to having only one 
			abstract method. The key difference lies in the intended usage and 
			purpose of the interface.</p>
			<p>Here are some points of distinction between a functional 
			interface and an ordinary interface:</p>
			<ol>
				<li>
				<p>Abstract Methods: An ordinary interface can have any number 
				of abstract methods. These methods define the contract that 
				implementing classes must adhere to. In contrast, a functional 
				interface can have only one abstract method, which represents 
				the primary behavior that the interface intends to encapsulate.</p>
				</li>
				<li>
				<p>Default and Static Methods: Both functional interfaces and 
				ordinary interfaces can have default and static methods. These 
				methods provide default implementations or utility methods that 
				can be used by implementing classes. However, the presence of 
				default and static methods does not affect the functional nature 
				of an interface.</p>
				</li>
				<li>
				<p>Lambda Expressions: The primary motivation behind functional 
				interfaces in Java is to enable the use of lambda expressions 
				and facilitate functional programming. Lambda expressions 
				provide a concise way to implement the single abstract method 
				defined in a functional interface. Ordinary interfaces do not 
				have the same association with lambda expressions and are not 
				typically used in functional programming contexts.</p>
				</li>
				<li>
				<p><code>@FunctionalInterface</code> Annotation: While it is not 
				mandatory to use the <code>@FunctionalInterface</code> 
				annotation with functional interfaces, it is recommended. This 
				annotation serves as a documentation tool and provides a 
				compile-time check to ensure that the interface qualifies as a 
				functional interface. It helps prevent accidental addition of 
				extra abstract methods to the interface.</p>
				</li>
			</ol>
			<p>In summary, the main difference between a functional interface 
			and an ordinary interface lies in their purpose and design. 
			Functional interfaces are specifically designed to support 
			functional programming and provide a single abstract method that can 
			be implemented using lambda expressions. On the other hand, ordinary 
			interfaces can have multiple abstract methods and are used for a 
			wider range of purposes in Java programming.</p>
			<blockquote><em>Author's note: Having learned what ChatGPT has to say on the 
			topic, lets see what Google Bard has to say.</em></blockquote>
		</div>
	</div>
</div>
<h3>The following was generated by Google Bard</h3>

<h4>Prompt: Explain functional interfaces in java.</h4>
<p>A functional interface is an interface that has exactly one abstract method. 
Functional interfaces are a new feature in Java 8, and they provide a way to 
represent functions in Java code. This can be useful for a variety of tasks, 
such as:</p>
<ul>
	<li><strong>Creating lambda expressions:</strong> Lambda expressions are a 
	new feature in Java 8 that allow you to create short, anonymous functions. 
	Functional interfaces are the target type for lambda expressions, which 
	means that you can use a lambda expression to implement the abstract method 
	of a functional interface.</li>
	<li><strong>Using streams:</strong> Streams are a new feature in Java 8 that 
	allow you to process data in a more functional way. Streams can be used to 
	perform operations such as filtering, mapping, and reducing data. Functional 
	interfaces are used to represent the operations that can be performed on 
	streams.</li>
</ul>
<p>Here is an example of a functional interface:</p>
<div class="a">
<pre>@FunctionalInterface
public interface Runnable {
  public void run();
}</pre>
</div>

<p>This interface has exactly one abstract method, <code>run()</code>. This 
method can be implemented by any class that wants to represent a function. For 
example, the following class implements the <code>Runnable</code> interface:</p>
<div class="a"> 
<pre>public class MyRunnable implements Runnable {
  @Override
  public void run() {
    System.out.println("Hello, world!");
  }
}</pre>
</div>
<p>This class can be used to create a new thread that prints the message "Hello, 
world!" to the console.</p>
<p>Functional interfaces are a powerful new feature in Java 8. They can be used 
to create lambda expressions, use streams, and implement other functional 
programming concepts.</p>
<p>Here are some of the benefits of using functional interfaces:</p>
<ul>
	<li><strong>They make code more concise and expressive:</strong> Lambda 
	expressions and streams can be used to write code that is more concise and 
	expressive than traditional Java code.</li>
	<li><strong>They make code more reusable:</strong> Functional interfaces can 
	be used to represent functions, which makes it easier to reuse code.</li>
	<li><strong>They make code more testable:</strong> Functional interfaces can 
	be easily mocked or stubbed in unit tests, which makes it easier to test 
	code that uses them.</li>
</ul>
<h4>Prompt: Provide and explain a sample program that uses a functional interface that 
doesn't involve lambda expressions.</h4>
<p>Sure, here is a sample program that uses a functional interface that doesn't 
involve lambda expressions:</p>
<div class="a"> 
<pre>
import java.util.List;
import java.util.Arrays;
import java.util.ArrayList;

public class FunctionalInterfaceWithoutLambdaExpressions {

  @FunctionalInterface
  public interface MyPredicate&lt;T&gt; {
    boolean test(T t);
  }

  public static void main(String[] args) {
    List&lt;String&gt; names = Arrays.asList("John", "Jane", "Mary");

    MyPredicate&lt;String&gt; isFemale = name -&gt; name.startsWith("J");

    List&lt;String&gt; femaleNames = filter(names, isFemale);

    for (String name : femaleNames) {
      System.out.println(name);
    }
  }

  private static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, MyPredicate&lt;T&gt; predicate) {
    List&lt;T&gt; filteredList = new ArrayList&lt;&gt;();

    for (T item : list) {
      if (predicate.test(item)) {
        filteredList.add(item);
      }
    }

    return filteredList;
  }
}</pre>
</div>
<p>According to Bard: This program prints the following output to the console:</p>
<pre>Jane
Mary</pre>
<p>This program uses the <code>MyPredicate</code> functional interface to filter 
a list of strings. The <code>MyPredicate</code> interface has a single abstract 
method, <code>test()</code>, which takes a <code>String</code> object as its 
argument and returns a <code>boolean</code> value. The <code>filter()</code> 
method uses the <code>MyPredicate</code> interface to filter a list of strings 
and return a new list of strings that only contains the strings that match the 
predicate.</p>
<p>Here is an explanation of how the program works:</p>
<ol>
	<li>The <code>MyPredicate</code> interface is a functional interface that 
	represents a predicate (boolean-valued function) of one argument.</li>
	<li>The <code>isFemale</code> variable is a reference to a <code>MyPredicate</code> 
	object that tests whether a string starts with the letter "J".</li>
	<li>The <code>femaleNames</code> variable is a reference to a <code>List</code> 
	object that contains the strings that match the <code>isFemale</code> 
	predicate.</li>
	<li>The <code>filter()</code> method uses the <code>isFemale</code> 
	predicate to filter the <code>names</code> list and return a new <code>List</code> 
	object that only contains the strings that match the predicate.</li>
	<li>The <code>for</code> loop iterates over the <code>femaleNames</code> 
	list and prints each string to the console.</li>
</ol>
<p>This program is a simple example of how to use a functional interface that 
doesn't involve lambda expressions.</p>
<blockquote><em>Author's note: Oops! It looks like Bard made a mistake on this 
one.</em></blockquote>
<blockquote><em>According to ChatGPT: the code contains a lambda expression. 
Specifically, the lambda expression is used when defining the variable </em>
<code><em>isFemale</em></code><em> of type </em><code><em>MyPredicate&lt;String&gt;</em></code><em>. 
The lambda expression </em><code><em>name -&gt; name.startsWith("J")</em></code><em> 
represents an implementation of the </em><code><em>test</em></code><em> method 
in the </em><code><em>MyPredicate</em></code><em> functional interface.</em></blockquote>
<blockquote><em>Lambda expressions are discussed and explained elsewhere in this 
eBook. Now back to Bard.</em></blockquote>

<h4>Prompt: How does that functional interface differ from an ordinary interface?</h4>
<p>According to Bard: The main difference between a functional interface and an ordinary interface 
is that a functional interface can only have one abstract method. This makes 
functional interfaces ideal for representing functions, as they can be used to 
create lambda expressions.</p>
<blockquote><em>Author's note: Having learned what ChatGPT and Bard have to say on the 
			topic, lets see what Microsoft Bing Chat has to say.</em></blockquote>
<h3>The following was generated by Microsoft Bing Chat</h3>
<h4>Prompt: Explain functional interfaces in java.</h4>

<p>A functional interface is an 
interface that contains only one abstract method. They can have only one 
functionality to exhibit. From Java 8 onwards, lambda expressions can be used to 
represent the instance of a functional interface. A functional interface can have 
any number of default methods</p>
<p>Functional interfaces are included in Java SE 8 with Lambda expressions and Method references in order to make code more readable, clean, and straightforward.
</p>
<p>Java provides a package called java.util.function which contains many functional interfaces. The interfaces in this package are general-purpose functional interfaces used by the JDK and are available to be used by user code as well.
</p>

<h4><a name="Prompt:_Provide">Prompt: Provide</a> and explain a sample program that uses a functional interface that 
doesn't involve lambda expressions.</h4>
<div class="a"> 
<pre>import java.util.function.Function;

public class Main {  
  public static void main(String[] args) {
  
    Function&lt;String, Integer&gt; length = new Function&lt;String, Integer&gt;() {
    
      @Override
      public Integer apply(String s) {
        return s.length();
      }
    };
    
    System.out.println(length.apply("Hello World!"));
  }
}</pre>
</div>
<p>In this example, we have created a functional interface called Function which 
takes a String as input and returns an Integer. </p>
<blockquote><em>Author's note: Actually the interface named Function was 
imported.</em></blockquote>
<p>We have then created an instance 
of this interface called length which returns the length of the input string. 
</p>
<blockquote><em>Author's note: The code defines an inner class that 
implements the <strong>Function</strong> interface. It creates an instance of 
that class and saves it in the reference variable named <strong>length</strong>. 
The code in the inner class overrides the inherited method named <strong>apply</strong> 
by returning the length of an incoming <strong>String</strong> as type <strong>
Integer</strong>.</em></blockquote>
<p>Finally, we have called the apply() method on the length instance to get the 
length of the string “Hello World!”.</p>
<blockquote></blockquote>
<blockquote><em>Author's note: This sample is a little more complicated than the previous 
samples in this lesson. Also the above explanation from Bing Chat is somewhat 
lacking. I will provide a little better explanation of this code from 
ChatGPT later.</em></blockquote>
<h4>Prompt: How does that functional interface differ from an ordinary interface?</h4>
<p>A functional interface is an interface that has only one abstract method. In 
other words, it is an interface that is designed to be used with lambda 
expressions. A normal interface, on the other hand, can have multiple abstract 
methods.</p>
<h3>The following text was generated by ChatGPT</h3>
<h4>Prompt: Explain the use of the java.util.function.Function interface.</h4>
			<p>The <code>java.util.function.Function</code> interface is a 
			functional interface introduced in Java 8 as part of the Java 
			Functional Programming paradigm. It represents a function that takes 
			an argument of one type and produces a result of another type. The 
			primary purpose of the <code>Function</code> interface is to 
			facilitate the transformation or mapping of values from one type to 
			another.</p>
			<p>The <code>Function</code> interface defines a single abstract 
			method called <code>apply</code>, which takes an input of type <code>
			T</code> and returns a result of type <code>R</code>. The method 
			signature is as follows:</p>
<p>R apply(T t);
</p>
<p>Here, <code>T</code> represents the type of the input argument, and <code>R</code> 
represents the type of the result.</p>
<blockquote><em>Author's note: The interface also contains three default methods:</em>
<ol>
	<li>

		<em>andThen</em>
	</li>
	<li>

		<em>Compose</em>
	</li>
	<li>

		<em>identity</em>
	</li>
</ol>
</blockquote>
<p>The <code>Function</code> interface is often used in various scenarios, 
including but not limited to:</p>
<ol>
	<li>
	<p>Mapping: It allows you to transform objects of one type into objects of 
	another type. For example, you can use a <code>Function</code> to convert a
	<code>String</code> to an <code>Integer</code> or to capitalize a <code>
	String</code>.</p>
	</li>
	<li>
	<p>Composing functions: You can combine multiple <code>Function</code> 
	instances together to create more complex transformations. The <code>
	Function</code> interface provides methods like <code>andThen</code> and
	<code>compose</code> that allow you to chain functions together.</p>
	</li>
	<li>
	<p>Stream operations: The <code>Function</code> interface is frequently used 
	in stream operations like <code>map</code>, where you can specify a function 
	to transform each element of a stream into a different type.</p>
	</li>
	<li>
	<p>Functional programming: The <code>Function</code> interface plays a 
	fundamental role in functional programming concepts, enabling higher-order 
	functions, currying, and other functional techniques.</p>
	</li>
</ol>
<p>By using the <code>Function</code> interface, you can write more concise and 
expressive code when performing transformations or mappings between different 
types. It promotes a functional style of programming and allows for greater code 
reuse and composability.</p>
<h4>Prompt: Explain the <a href="#Prompt:_Provide">given code</a>.</h4>
<div class="flex flex-grow flex-col gap-3">
	<div class="min-h-[20px] flex flex-col items-start gap-4 whitespace-pre-wrap break-words">
		<div class="markdown prose w-full break-words dark:prose-invert light">
			<p>The given code is written in Java and demonstrates the usage of 
			the <code>Function</code> interface from the <code>
			java.util.function</code> package.</p>
			<p>Let's go through the code step by step:</p>
			<ol>
				<li>
				<p>The code begins with the import statement <code>import 
				java.util.function.Function;</code>, which imports the <code>
				Function</code> interface from the <code>java.util.function</code> 
				package. This interface represents a function that takes one 
				argument and produces a result.</p>
				</li>
				<li>
				<p>The code defines a public class named <code>Main</code>.</p>
				</li>
				<li>
				<p>Inside the <code>Main</code> class, there is a <code>main</code> 
				method, which serves as the entry point for the program.</p>
				</li>
				<li>
				<p>Within the <code>main</code> method, a variable named <code>
				length</code> is declared and initialized with an anonymous 
				class that implements the <code>Function&lt;String, Integer&gt;</code> 
				interface. This anonymous class overrides the <code>apply</code> 
				method of the <code>Function</code> interface.</p>
				</li>
				<li>
				<p>The <code>Function&lt;String, Integer&gt;</code> interface is a 
				functional interface that takes a <code>String</code> as input 
				and returns an <code>Integer</code> as output. In this case, the
				<code>String</code> represents a text, and the <code>Integer</code> 
				represents the length of that text.</p>
				</li>
				<li>
				<p>Inside the overridden <code>apply</code> method, the <code>
				s.length()</code> expression calculates the length of the 
				provided string <code>s</code>.</p>
				</li>
				<li>
				<p>The <code>length</code> variable now represents an instance 
				of the anonymous class that implements the <code>Function</code> 
				interface. It can be used as a function to calculate the length 
				of a string.</p>
				</li>
				<li>
				<p>Finally, the <code>length.apply("Hello World!")</code> 
				statement is executed, which applies the <code>length</code> 
				function to the string "Hello World!". It returns the length of 
				the string, which is 12 in this case.</p>
				</li>
				<li>
				<p>The <code>System.out.println</code> statement prints the 
				result of <code>length.apply("Hello World!")</code>, which is 
				12, to the console.</p>
				</li>
			</ol>
			<p>To summarize, the code uses an anonymous class to implement the
			<code>Function</code> interface and calculate the length of a given 
			string.</p>
		</div>
	</div>
</div>
<h2><a name="Summary">Summary</a></h2>
<p>This lesson has used text from ChatGPT, Bard, and Bing Chat in an attempt to explain and demonstrate 
the use of functional interfaces. It 
	also explains some other Java features that are important in understanding 
	functional interfaces but which may not be familiar to the reader.</p>
	
	
<p>As it turns out, a functional interface is not a new construct in Java. It is 
simply a restricted version of an ordinary interface. An ordinary interface in Java can have multiple abstract methods, 
			whereas a functional interface is limited to having only one 
			abstract method. The key difference lies in the intended usage and 
			purpose of the interface.</p>
			
<p>Either interface can also contain default methods and static methods but only 
one abstract method is allowed in a functional interface.</p>

	<h2><a name="Miscellaneous">Miscellaneous</a></h2>
	<p>This section contains a variety of miscellaneous information.</p>

<!--Set border to 15 to create a note. Paragraph elements inside the note are allowed but not required.-->
<div class="a">
	<p><strong>Housekeeping material</strong>
				</p>
				<ul>
					<li>Author: Prof. Richard G. Baldwin</li>
					<li>Lesson title: Functional Interfaces</li>
					<li>File: FunctionalInterface01.htm</li>
					<li>Published: 06/17/2023</li>
				</ul>
</div>

<!--Set border to 15 to create a note. Paragraph elements inside the note are allowed but not required.-->
	<p>-end- </p>


</body>
</html>